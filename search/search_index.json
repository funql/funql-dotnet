{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#complex-queries-made-simple","title":"Complex queries made simple","text":"<p>FunQL .NET is the official .NET implementation of FunQL, the open-source Functional Query Language. It provides a simple way to add powerful query capabilities to existing REST APIs or build standalone FunQL APIs.</p> <p>With FunQL .NET, you can:</p> <ul> <li>Enhance existing REST APIs with ready-to-use components for filtering, sorting, pagination, and more.</li> <li>Build standalone FunQL APIs that harness the full power of the FunQL Query Language.</li> <li>Integrate with LINQ and EF Core to transform FunQL queries into efficient database queries.</li> </ul> <p>FunQL .NET is designed to be lightweight, efficient, and easy to integrate, giving developers full control over API behavior without unnecessary complexity. We continuously improve FunQL .NET to support new use cases and enhance developer experience.</p> <p>Let's get started with FunQL .NET!</p> <p>Get started Learn more</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>This guide will help you get started with FunQL .NET quickly.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#1-create-a-new-web-api-project","title":"1. Create a new Web API project","text":"<p>Create a new ASP.NET Core Web API project using the .NET CLI.</p> <pre><code>dotnet new webapi -n Demo\n</code></pre> <p>This will create a new directory called <code>Demo</code> containing your project's files.</p> <p>You can now open the <code>Demo</code> directory or the <code>Demo.csproj</code> file in your favourite code editor.</p>"},{"location":"getting-started/#2-add-the-funql-package","title":"2. Add the FunQL package","text":"<p>Add the FunQL  package to your  project using the .NET CLI:</p> <pre><code>dotnet add package FunQL\n</code></pre> <p>Note</p> <p>This will install both FunQL.Core and FunQL.Linq, providing all the essential components to get you started quickly.</p>"},{"location":"getting-started/#create-the-data-model","title":"Create the data model","text":"<p>For this example we'll create an API for querying LEGO sets, so create a <code>Set</code> data model.</p> <pre><code>public sealed record Set(string Name, double Price, DateTime LaunchTime);\n</code></pre>"},{"location":"getting-started/#create-the-schema","title":"Create the schema","text":"<p>A schema defines the structure and behavior of your API, including the available requests, their parameters, and the  data models they operate on. Create a schema and add the <code>Core</code> and <code>LINQ</code> features to enable query parsing, validation,  and execution. Then add the <code>listSets</code> request with support for filtering and sorting, ready to query <code>Set</code> data.</p> <pre><code>public sealed class DemoSchema : Schema\n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    {\n        // ===== Features =====\n        // Add all core features: Parse, Print, Validate, Visit and Execute\n        schema.AddCoreFeatures();\n        // Add LINQ feature so FunQL can translate FunQL queries to LINQ expressions, e.g. for use with EFCore DbSet\n        schema.AddLinqFeature();\n\n        // ===== Requests =====\n        // Add the 'listSets()' request\n        schema.Request(\"listSets\")\n            // Enable support for the 'filter()' parameter\n            .SupportsFilter()\n            // Enable support for the 'sort()' parameter\n            .SupportsSort()\n            // Configure the 'listSets()' return type: 'List&lt;Set&gt;'\n            .ReturnsListOfObjects&lt;Set&gt;(set =&gt;\n            {\n                // Configure each field of the data model\n                set.SimpleField(it =&gt; it.Name)\n                    .HasName(\"name\")\n                    .SupportsFilter(it =&gt; it.SupportsStringFilterFunctions())\n                    .SupportsSort(it =&gt; it.SupportsStringFieldFunctions());\n                set.SimpleField(it =&gt; it.Price)\n                    .HasName(\"price\")\n                    .SupportsFilter(it =&gt; it.SupportsDoubleFilterFunctions())\n                    .SupportsSort(it =&gt; it.SupportsDoubleFieldFunctions());\n                set.SimpleField(it =&gt; it.LaunchTime)\n                    .HasName(\"launchTime\")\n                    .SupportsFilter(it =&gt; it.SupportsDateTimeFilterFunctions())\n                    .SupportsSort(it =&gt; it.SupportsDateTimeFieldFunctions());\n            });\n    }\n}\n</code></pre>"},{"location":"getting-started/#add-funql-services","title":"Add FunQL services","text":"<p>In <code>Program.cs</code>, add the <code>DemoSchema</code> as a singleton to the application services, ready to be injected in request  handlers.</p> <pre><code>var builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddSingleton&lt;DemoSchema&gt;();\n</code></pre>"},{"location":"getting-started/#create-a-rest-endpoint-with-funql-support","title":"Create a REST endpoint with FunQL support","text":"<p>With the <code>DemoSchema</code> fully configured, we can use it to create a REST endpoint to filter and sort LEGO sets. Update  <code>Program.cs</code> to add the <code>/sets</code> endpoint to filter and sort a list of LEGO sets.  </p> <pre><code>app.MapGet(\"/sets\", async (string filter, string sort, DemoSchema schema) =&gt;\n{\n    // We use demo data for this example \u2014 Normally you would e.g. use an Entity Framework Core DbContext to query the \n    // database directly\n    IQueryable&lt;Set&gt; sets = new List&lt;Set&gt;\n    {\n        new(\"LEGO Star Wars Millennium Falcon\", 849.99, DateTime.Parse(\"2017-10-01\", styles: DateTimeStyles.AdjustToUniversal)),\n        new(\"LEGO Star Wars The Razor Crest\", 599.99, DateTime.Parse(\"2022-10-03\", styles: DateTimeStyles.AdjustToUniversal)),\n        new(\"LEGO DC Batman Batmobile Tumbler\", 269.99, DateTime.Parse(\"2021-11-01\", styles: DateTimeStyles.AdjustToUniversal)),\n        new(\"LEGO Harry Potter Hogwarts Castle\", 469.99, DateTime.Parse(\"2018-09-01\", styles: DateTimeStyles.AdjustToUniversal)),\n    }.AsQueryable();\n\n    var result = await sets\n        .ExecuteRequestForParameters(\n            schema, \n            requestName: \"listSets\", \n            filter: filter, \n            sort: sort\n        );\n\n    return result.Data;\n});\n</code></pre> <p>And that is it, you have now successfully added FunQL support to your API! \ud83d\ude80</p>"},{"location":"getting-started/#execute-a-query","title":"Execute a query","text":"<p>Run the project using the .NET CLI:</p> <pre><code>dotnet run\n</code></pre> <p>If everything is set up correctly, you should be able to open http://localhost:5000/sets  to query the LEGO sets. Looking for LEGO Star Wars sets that cost at least \u20ac500 and were launched after 2010, sorted by price? Just ask:</p> <pre><code>http://localhost:5000/sets\n    ?filter=and(has(upper(name), \"STAR WARS\"), gte(price, 500), gt(year(launchTime), 2010))\n    &amp;sort=desc(price)\n</code></pre>"},{"location":"additional-resources/design-philosophy/","title":"FunQL .NET design philosophy","text":"<p>Before you start using FunQL .NET, it's helpful to understand the design principles behind it. Our goal is to provide developers with the right tools to build powerful, flexible APIs in a way that's both intuitive and easy to use.</p> <p>To learn more about FunQL, visit funql.io.</p>"},{"location":"additional-resources/design-philosophy/#everything-you-would-expect","title":"Everything you would expect","text":"<p>FunQL .NET is designed with simplicity and efficiency in mind. We focus on providing the core functionalities that are essential to most API workflows while ensuring a smooth and seamless developer experience.</p> <ul> <li> <p> It just works</p> <p>FunQL .NET processes raw text into functional queries, handling lexical analysis, tokenization, syntax parsing, and Abstract Syntax Tree (AST) generation so you don't have to.</p> </li> <li> <p> Supports LINQ and EF Core</p> <p>Translates FunQL queries into LINQ expressions for seamless database interaction with EF Core.</p> </li> <li> <p> Zero dependencies</p> <p>Requires only .NET Core; no additional frameworks or external libraries needed.</p> </li> <li> <p> Built-in validation</p> <p>Enforces query parameter constraints, ensuring valid API queries.</p> </li> </ul>"},{"location":"additional-resources/design-philosophy/#built-for-developers-by-developers","title":"Built for developers, by developers","text":"<p>FunQL .NET is built with developers in mind. We believe in keeping things transparent, customizable, and flexible. It's designed to be simple, yet adaptable to meet the unique needs of any project.</p> <ul> <li> <p> Explicit by default</p> <p>No hidden behaviors or 'automagic' configurations. FunQL .NET enforces explicit schema definitions, giving developers full control and clarity over API behavior.</p> </li> <li> <p> Highly extensible</p> <p>Every component is customizable: override, extend, or replace parts to fit your project's needs.</p> </li> <li> <p> Configurable JSON serialization</p> <p>Works out of the box with <code>System.Text.Json</code> and supports external JSON libraries like <code>NewtonSoft.Json</code> for greater flexibility.</p> </li> <li> <p> Easy integration</p> <p>Install via NuGet for a seamless setup.</p> </li> </ul>"},{"location":"additional-resources/licensing/","title":"Licensing","text":"<p>FunQL .NET is available under two licensing options: the GPLv2 license for open-source use and a Commercial license for proprietary, closed-source use.</p> <p>Each option is designed to meet different needs. Visit funql.io to find out which license is right for your project.</p> <p>Learn more</p>"},{"location":"defining-a-schema/","title":"Defining a Schema","text":"<p>A <code>Schema</code> in FunQL .NET serves as the core configuration and entry point for processing FunQL queries. It defines what  data can be queried and which query options are supported (filtering, sorting, pagination). </p> <p>This guide walks you through building a schema and configuring it to handle FunQL requests.</p>"},{"location":"defining-a-schema/#implementing-the-schema","title":"Implementing the Schema","text":"<p>To get started, create a class that inherits from FunQL's <code>Schema</code> and override the <code>OnInitializeSchema()</code> method. This  method is where you configure your schema, including supported features and requests:</p> <pre><code>public sealed class ApiSchema : Schema\n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    {\n        // Schema configuration goes here\n    }\n}\n</code></pre> <p>Note</p> <p>While it's usually enough to implement <code>OnInitializeSchema(ISchemaConfigBuilder)</code>, you may also implement  <code>OnFinalizeSchema(ISchemaConfigBuilder)</code>, which can be used for additional customizations, like modifying default  settings or applying conventions.</p> <p>FunQL schemas prioritize explicit configurations, providing developers with complete control and predictability. There  are no hidden behaviors or 'automagic' configurations \u2014 every feature and setting must be explicitly defined.</p>"},{"location":"defining-a-schema/#adding-features","title":"Adding features","text":"<p>Features define the capabilities of your schema, from parsing and validating FunQL queries to translating them into  LINQ expressions for execution.</p> <p>To get started quickly, add the most commonly used features:</p> <ul> <li>Core features: Enables common operations like parsing, query validation, and execution.</li> <li>LINQ feature: Translates FunQL queries into LINQ expressions, which is useful for querying in-memory collections    or external databases (e.g., using Entity Framework (EF) Core).</li> </ul> <pre><code>public sealed class ApiSchema : Schema\n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    {\n        // Add core parsing, validation and execution features\n        schema.AddCoreFeatures();\n        // Enable LINQ query translation\n        schema.AddLinqFeature();\n    }\n}\n</code></pre> <p>By adding only the features you need, you ensure that your schema remains lightweight and optimized for your use case.</p> <p>Learn more about features \u2192</p>"},{"location":"defining-a-schema/#adding-requests","title":"Adding requests","text":"<p>In FunQL, requests define the entry points to your data. They represent the operations that users can query, specifying  what data can be fetched and how it can be filtered or sorted.</p>"},{"location":"defining-a-schema/#key-concepts-of-requests","title":"Key concepts of requests","text":"<ol> <li>Request name: Each request has a unique identifier, like <code>listSets</code>, used in queries to specify the operation to     execute.</li> <li>Parameters: Requests specify which parameters they support, like the <code>filter()</code> and <code>sort()</code> parameters to     provide advanced querying capabilities.</li> <li>Return type: Requests define the type of data returned, such as a list of objects, along with the fields that can     be queried, filtered, and sorted.</li> </ol>"},{"location":"defining-a-schema/#example-request","title":"Example request","text":"<p>As an example, we'll configure a <code>listSets()</code> request with support for filtering and sorting a list of LEGO sets. Once  configured, the schema is ready to handle advanced FunQL queries like:</p> RESTQL <pre><code>GET http://localhost:5000/sets\n  ?filter=and(\n    has(upper(name), \"STAR WARS\"),\n    gte(price, 500),\n    gt(year(launchTime), 2010)\n  )\n  &amp;sort=desc(price)\n</code></pre> <pre><code>listSets(\n  filter(\n    and(\n      has(upper(name), \"STAR WARS\"),\n      gte(price, 500),\n      gt(year(launchTime), 2010)\n    )\n  ),\n  sort(\n    desc(price)\n  )\n)\n</code></pre>"},{"location":"defining-a-schema/#define-the-data-model","title":"Define the data model","text":"<p>Start by defining the <code>Set</code> data model, which represents the LEGO sets and serves as the return type of the <code>listSets()</code>  request:</p> <pre><code>public sealed record Set(string Name, double Price, DateTime LaunchTime);\n</code></pre> <p>The fields <code>Name</code>, <code>Price</code>, and <code>LaunchTime</code> will later be configured to support filtering and sorting.</p>"},{"location":"defining-a-schema/#add-the-request","title":"Add the request","text":"<p>Define the <code>listSets</code> request in the schema:</p> <pre><code>public sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {        \n        // Add the 'listSets' request \n        schema.Request(\"listSets\")\n            // Enable support for the 'filter()' parameter \n            .SupportsFilter()\n            // Enable support for the 'sort()' parameter \n            .SupportsSort()            \n            // Define the return type as a list of 'Set' objects (List&lt;Set&gt;)\n            .ReturnsListOfObjects&lt;Set&gt;(set =&gt;\n            {\n                // Field configurations go here\n            });\n    }\n}\n</code></pre> <p>At this point, the <code>listSets</code> request is defined and supports the <code>filter()</code> and <code>sort()</code> parameters. However, the  fields must be explicitly configured before they can be filtered and sorted on, so let's configure this next.</p> <p>Learn more about requests \u2192</p>"},{"location":"defining-a-schema/#configure-fields","title":"Configure fields","text":"<p>Fields define which properties of the data model can be queried, filtered, and sorted. Expose the <code>Set</code> properties  (<code>Name</code>, <code>Price</code>, and <code>LaunchTime</code>) for filtering and sorting:</p> <pre><code>public sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {\n        schema.Request(\"listSets\")\n            .SupportsFilter()\n            .SupportsSort()            \n            .ReturnsListOfObjects&lt;Set&gt;(set =&gt;\n            {\n                // Configure the 'Name' field\n                set.SimpleField(it =&gt; it.Name)\n                    // Override the default name ('Name') to use its JSON name\n                    .HasName(\"name\")\n                    // Enable support for filtering on this field\n                    .SupportsFilter(it =&gt; \n                        // Enable String functions like:\n                        // - has(name, \"War\")\n                        // - stw(upper(name), \"STAR\")\n                        it.SupportsStringFilterFunctions()\n                    )\n                    // Enable support for sorting on this field\n                    .SupportsSort(it =&gt; \n                        // Enable String functions like:\n                        // - asc(lower(name))\n                        // - desc(upper(name))\n                        it.SupportsStringFieldFunctions()\n                    );\n\n                set.SimpleField(it =&gt; it.Price)\n                    .HasName(\"price\")\n                    .SupportsFilter(it =&gt; \n                        // Enable Double functions like:\n                        // - eq(round(price), 100)\n                        it.SupportsDoubleFilterFunctions()\n                    )\n                    .SupportsSort(it =&gt; it.SupportsDoubleFieldFunctions());\n\n                set.SimpleField(it =&gt; it.LaunchTime)\n                    .HasName(\"launchTime\")\n                    .SupportsFilter(it =&gt;\n                        // Enable DateTime functions like:\n                        // - gte(year(launchTime), 2010)\n                        it.SupportsDateTimeFilterFunctions()\n                    )\n                    .SupportsSort(it =&gt; it.SupportsDateTimeFieldFunctions());\n            });\n    }\n}\n</code></pre> <p>The <code>Schema</code> is now fully configured and ready to handle <code>listSets</code> requests.</p> <p>Learn more about fields \u2192</p>"},{"location":"defining-a-schema/#next-steps","title":"Next steps","text":"<p>Now that you've learned how to define a schema, let's learn how to execute a query.</p>"},{"location":"defining-a-schema/requests/","title":"Requests","text":"<p>Work in Progress</p> <p>We are actively working on the documentation for FunQL .NET. Please check back later or visit our repository to track progress or contribute.</p>"},{"location":"defining-a-schema/features/","title":"Features","text":"<p>Work in Progress</p> <p>We are actively working on the documentation for FunQL .NET. Please check back later or visit our repository to track progress or contribute.</p>"},{"location":"defining-a-schema/fields/","title":"Fields","text":"<p>Work in Progress</p> <p>We are actively working on the documentation for FunQL .NET. Please check back later or visit our repository to track progress or contribute.</p>"},{"location":"defining-a-schema/parameters/","title":"Parameters","text":"<p>Work in Progress</p> <p>We are actively working on the documentation for FunQL .NET. Please check back later or visit our repository to track progress or contribute.</p>"},{"location":"examples/","title":"Examples","text":"<p>FunQL .NET comes with practical examples that demonstrate common use cases and integration patterns to get you started  quickly.</p>"},{"location":"examples/#basic-example","title":"Basic Example","text":"<p>The Basic example is a minimal, self-contained console application that demonstrates how to:</p> <ul> <li>Configure a FunQL schema</li> <li>Filter and sort data using FunQL query parameters</li> </ul> <p>Learn more about the Basic example \u2192</p>"},{"location":"examples/#webapi-example","title":"WebApi Example","text":"<p>The WebApi example showcases how to integrate FunQL into a real-world ASP.NET Core Web API application. This example covers:</p> <ul> <li>Setting up FunQL in an ASP.NET Core project</li> <li>Integrating with Entity Framework Core (EF Core)</li> <li>Integrating with Noda Time</li> <li>Creating minimal APIs with FunQL support</li> </ul> <p>Learn more about the WebApi example \u2192</p>"},{"location":"examples/basic/","title":"Basic","text":"<p>Work in Progress</p> <p>We are actively working on the documentation for FunQL .NET. Please check back later or visit our repository to track progress or contribute.</p>"},{"location":"examples/webapi/","title":"WebApi","text":"<p>Work in Progress</p> <p>We are actively working on the documentation for FunQL .NET. Please check back later or visit our repository to track progress or contribute.</p>"},{"location":"executing-queries/","title":"Executing queries","text":"<p>Once the <code>Schema</code> is set up, it can be used to execute FunQL queries. All you need for this is an <code>IQueryable</code> data  source that FunQL uses to query the data. </p> <p>This section will explain more about how to query data and the underlying execution pipeline.</p>"},{"location":"executing-queries/#execution-pipeline","title":"Execution pipeline","text":"<p>Executing a FunQL request involves several steps, including parsing, validating, LINQ translation, and the actual query  execution. While you can use the <code>Schema</code> to handle these steps manually, the FunQL execution pipeline simplifies this  process by ensuring that all steps are performed in the correct order and in the right way, reducing complexity for developers.</p> <p>Learn more about the execution pipeline \u2192</p>"},{"location":"executing-queries/#example-request","title":"Example request","text":"<p>For this example, we will query an in-memory list of LEGO sets, which we configured in Defining a schema. FunQL provides two execution methods:</p> <ol> <li><code>ExecuteRequestForParameters()</code>: Designed for REST APIs where FunQL parameters like <code>filter</code> and <code>sort</code> are     passed as URL query parameters.</li> <li><code>ExecuteRequest()</code>: Designed for full FunQL queries, treating FunQL as a query language (QL). This approach     combines all parameters into a single query.</li> </ol> RESTQL <pre><code>// Define the data model\npublic sealed record Set(string Name, double Price, DateTime LaunchTime);\n\n// Prepare in-memory data\nvar sets = new List&lt;Set&gt;\n{\n    new(\"LEGO Star Wars Millennium Falcon\", 849.99, new DateTime(2017, 10, 01)),\n    new(\"LEGO Star Wars The Razor Crest\", 599.99, new DateTime(2022, 10, 03)),\n    new(\"LEGO DC Batman Batmobile Tumbler\", 269.99, new DateTime(2021, 11, 01)),\n    new(\"LEGO Harry Potter Hogwarts Castle\", 469.99, new DateTime(2018, 09, 01)),\n};\n\n// Define query parameters\nconst string filter = @\"and(\n  has(upper(name), \"\"STAR WARS\"\"),\n  gte(price, 500),\n  gt(year(launchTime), 2010)\n)\";\nconst string sort = \"desc(price)\";\n\n// Create the configured schema\nvar schema = new ApiSchema();\n\n// Execute the listSets() FunQL request for the 'filter' and 'sort' parameters\nvar result = await sets\n    .ExecuteRequestForParameters(\n        schema, \n        requestName: \"listSets\", \n        filter: filter, \n        sort: sort\n    );\n</code></pre> <p>The <code>ExecuteRequestForParameters()</code> method is ideal for REST APIs. It will process the <code>filter</code> and <code>sort</code>  parameters using the FunQL execution pipeline, which runs the following steps:</p> <ol> <li>Parse the <code>filter</code> and <code>sort</code> parameters using the <code>listSets</code> request configuration</li> <li>Validate the parameters based on the <code>listSets</code> request configuration</li> <li>Translate the parameters to LINQ expressions</li> <li>Apply the LINQ expressions to given <code>IQueryable&lt;Set&gt;</code></li> <li>Execute the query, fetching the filtered and sorted result</li> </ol> <pre><code>// Define the data model\npublic sealed record Set(string Name, double Price, DateTime LaunchTime);\n\n// Prepare in-memory data\nvar sets = new List&lt;Set&gt;\n{\n    new(\"LEGO Star Wars Millennium Falcon\", 849.99, new DateTime(2017, 10, 01)),\n    new(\"LEGO Star Wars The Razor Crest\", 599.99, new DateTime(2022, 10, 03)),\n    new(\"LEGO DC Batman Batmobile Tumbler\", 269.99, new DateTime(2021, 11, 01)),\n    new(\"LEGO Harry Potter Hogwarts Castle\", 469.99, new DateTime(2018, 09, 01)),\n};\n\n// Define FunQL request \nconst string request = @\"listSets(\n  filter(\n    and(\n      has(upper(name), \"\"STAR WARS\"\"),\n      gte(price, 500),\n      gt(year(launchTime), 2010)\n    )\n  ),\n  sort(\n    desc(price)\n  )\n)\";\n\n// Create the configured schema\nvar schema = new ApiSchema();\n\n// Execute the listSets() FunQL request\nvar result = await sets.AsQueryable()\n    .ExecuteRequest(schema, request);\n</code></pre> <p>The <code>ExecuteRequest()</code> method is designed for use cases where FunQL acts as a fully integrated query language. It  will process the <code>request</code> using the FunQL execution pipeline, which runs the following steps:</p> <ol> <li>Parse the <code>request</code> using the <code>listSets</code> request configuration</li> <li>Validate the parameters based on the <code>listSets</code> request configuration</li> <li>Translate the parameters to LINQ expressions</li> <li>Apply the LINQ expressions to given <code>IQueryable&lt;Set&gt;</code></li> <li>Execute the query, fetching the filtered and sorted result</li> </ol> <p>This example demonstrates how to query an in-memory data source. However, in real-world applications, you will typically  need to:</p> <ul> <li> <p>Query an external database: FunQL translates queries into LINQ expressions, enabling seamless integration with any   LINQ-compatible data provider, such as Entity Framework Core, Dapper, or others. This allows you to execute queries    directly against your database.</p> <p>Learn how to integrate FunQL with Entity Framework Core \u2192</p> </li> <li> <p>Enhance your REST API with FunQL: Utilize FunQL as part of your REST API by supporting advanced query capabilities    like filtering, sorting, and pagination through URL query parameters.</p> <p>Learn how to use FunQL in a REST API \u2192</p> </li> </ul>"},{"location":"executing-queries/pipeline/","title":"Execution pipeline","text":"<p>Work in Progress</p> <p>We are actively working on the documentation for FunQL .NET. Please check back later or visit our repository to track progress or contribute.</p>"},{"location":"integrations/","title":"Integrations","text":"<p>FunQL .NET is designed with extensibility at its core, making it highly adaptable to different technologies and  libraries in the .NET ecosystem. This section covers how popular .NET libraries can be integrated with FunQL.</p>"},{"location":"integrations/#entity-framework-core","title":"Entity Framework Core","text":"<p>FunQL seamlessly integrates with Entity Framework Core, using <code>IQueryable</code> LINQ expressions that EF Core efficiently translates into database queries. While this integration works out of the box, you can enhance it further by implementing EF Core-specific optimizations, such as using <code>CountAsync()</code> for improved async performance with FunQL's <code>count()</code> parameter.</p> <p>Learn more about integrating Entity Framework Core \u2192</p>"},{"location":"integrations/#nodatime","title":"NodaTime","text":"<p>Noda Time is a great alternative date and time API for .NET. Using NodaTime with FunQL requires configuring JSON serialization to handle NodaTime types (<code>Instant</code>, <code>LocalDate</code>, <code>LocalDateTime</code>). Additionally, to use FunQL DateTime functions (<code>year()</code>, <code>month()</code>, <code>day()</code>) with NodaTime types, you'll need to add a custom LINQ  translator.</p> <p>Learn more about integrating NodaTime \u2192</p>"},{"location":"integrations/#newtonsoftjson","title":"Newtonsoft.Json","text":"<p>FunQL uses System.Text.Json  by default for JSON serialization, as it's built into .NET. For projects requiring Newtonsoft.Json (JSON.NET), FunQL allows for fully customizing the serialization process.</p> <p>Learn more about integrating Newtonsoft.Json \u2192</p>"},{"location":"integrations/efcore/","title":"Entity Framework Core","text":"<p>Entity Framework Core (EF Core) is a powerful Object-Relational Mapper  (ORM) for .NET that allows developers to interact with databases using .NET objects and LINQ. FunQL seamlessly  integrates with EF Core by translating FunQL queries into LINQ expressions, which EF Core further translates to database  queries.</p> <p>This section will explain more about integrating FunQL with EF Core and using EF Core-specific optimizations (e.g.,  <code>CountAsync</code> for asynchronous count operations).</p> <p>You can also refer to the WebApi sample for a practical example of the EF Core integration.</p>"},{"location":"integrations/efcore/#getting-started","title":"Getting started","text":"<p>FunQL offers seamless integration with EF Core by working directly with <code>IQueryable</code> objects. Create a <code>DbContext</code> and  then directly execute FunQL queries using <code>DbSet&lt;T&gt;</code>, which implements <code>IQueryable</code>.</p>"},{"location":"integrations/efcore/#1-create-dbcontext","title":"1. Create DbContext","text":"<p>To begin, let's define a simple <code>DbContext</code> that represents our database. In this example, we'll create a context for  querying LEGO sets (as configured in Defining a Schema):</p> <pre><code>public sealed record Set(string Name, double Price, DateTime LaunchTime);\n\npublic sealed class ApiSchema : Schema\n{\n    // Code omitted for brevity, see 'Defining a Schema'\n}\n\npublic class ApiContext : DbContext \n{\n    public DbSet&lt;Set&gt; Sets { get; set; }    \n\n    protected override void OnConfiguring(DbContextOptionsBuilder options)\n    {\n        // Replace with your database configuration\n        options.UseSqlServer(\"YourConnectionStringHere\");\n    }\n}\n</code></pre>"},{"location":"integrations/efcore/#2-execute-funql-query","title":"2. Execute FunQL query","text":"<p>With the <code>DbContext</code> configured, you can execute FunQL queries directly on a <code>DbSet&lt;T&gt;</code>. FunQL translates these queries into LINQ expressions, which EF Core then optimizes into database queries.</p> <p>Here's an example that queries LEGO sets priced at or above 500, sorted by price in descending order:</p> <pre><code>// Create the configured DbContext\nvar context = new ApiContext();\n// Create the configured schema\nvar schema = new ApiSchema();\n\n// Execute the listSets() FunQL request on ApiContext.Sets\nvar result = await context\n    .Sets\n    .ExecuteRequestForParameters(\n        schema, \n        requestName: \"listSets\", \n        filter: \"gte(price, 500)\", \n        sort: \"desc(price)\"\n    );\n</code></pre> <p>Note</p> <p>In a real-world application, it's recommended to configure and manage your <code>DbContext</code> using dependency injection  and not create an instance directly.</p> <p>That's it! FunQL seamlessly filters, sorts, and queries your database directly through the <code>DbSet&lt;Set&gt;</code>, leveraging EF  Core's powerful capabilities.</p>"},{"location":"integrations/efcore/#optimizing-async-support","title":"Optimizing async support","text":"<p>While FunQL integrates with EF Core out of the box, operations like counting can be further optimized. Using EF Core's  specialized async methods, such as <code>CountAsync()</code> for counting and <code>ToListAsync()</code> for data retrieval, improves performance.</p> <p>Note</p> <p>FunQL executes LINQ queries asynchronously out of the box if <code>IQueryable</code> implements <code>IAsyncEnumerable</code>. The  implementation is equivalent to calling EF Core's <code>ToListAsync()</code> method. However, there's no generic interface for  async counting, making it necessary to explicitly use EF Core's <code>CountAsync()</code> via a custom execution handler when  using FunQL's <code>count()</code> parameter.</p>"},{"location":"integrations/efcore/#1-create-execution-handler","title":"1. Create execution handler","text":"<p>Implement a custom <code>IExecutionHandler</code> to override the default implementation and directly use EF Core's async methods:</p> <pre><code>/// &lt;summary&gt;\n/// Execution handler that executes the &lt;see cref=\"ExecuteLinqExecuteContext.Queryable\"/&gt; to get the data for\n/// &lt;see cref=\"IExecutorState.Request\"/&gt;.\n/// &lt;para&gt;\n/// This handler replaces the &lt;see cref=\"ExecuteLinqExecutionHandler\"/&gt; so it can use the async EFCore methods instead:\n/// &lt;list type=\"bullet\"&gt;\n/// &lt;item&gt;\n/// &lt;description&gt;\n///   &lt;see cref=\"EntityFrameworkQueryableExtensions.ToListAsync{T}(IQueryable{T},CancellationToken)\"/&gt; to get the data\n/// &lt;/description&gt;\n/// &lt;/item&gt;\n/// &lt;item&gt;\n/// &lt;description&gt;\n///   &lt;see cref=\"EntityFrameworkQueryableExtensions.CountAsync{T}(IQueryable{T},CancellationToken)\"/&gt; to count the items\n/// &lt;/description&gt;\n/// &lt;/item&gt;\n/// &lt;/list&gt;\n/// &lt;/para&gt;\n/// &lt;/summary&gt;\n/// &lt;remarks&gt;\n/// Requires &lt;see cref=\"ExecuteLinqExecuteContext\"/&gt; context, just like &lt;see cref=\"ExecuteLinqExecutionHandler\"/&gt;.\n///\n/// &lt;para&gt;\n/// Note that &lt;see cref=\"ExecuteLinqExecutionHandler\"/&gt; already handles &lt;see cref=\"IAsyncEnumerable{T}\"/&gt; the same or\n/// similar to how &lt;see cref=\"EntityFrameworkQueryableExtensions.ToListAsync{T}(IQueryable{T},CancellationToken)\"/&gt;\n/// handles it. Only the &lt;see cref=\"EntityFrameworkQueryableExtensions.CountAsync{T}(IQueryable{T},CancellationToken)\"/&gt;\n/// is different as there's no abstract way to count asynchronously; this is a specific implementation in EFCore.\n/// &lt;/para&gt;\n/// &lt;/remarks&gt;\npublic class EntityFrameworkCoreExecuteLinqExecutionHandler : IExecutionHandler\n{\n    /// &lt;summary&gt;Default name of this handler.&lt;/summary&gt;\n    public const string DefaultName = \"WebApi.EntityFrameworkCoreExecuteLinqExecutionHandler\";\n\n    // Handler should be called late in the pipeline as LINQ does the data fetching, which is pretty much at the end\n    /// &lt;summary&gt;Default order of this handler.&lt;/summary&gt;\n    /// &lt;remarks&gt;\n    /// Should be called before &lt;see cref=\"ExecuteLinqExecutionHandler\"/&gt; so this handler can take over the execution.\n    /// &lt;/remarks&gt;\n    public const int DefaultOrder = ExecuteLinqExecutionHandler.DefaultOrder - 100;\n\n    /// &lt;inheritdoc/&gt;\n    public async Task Execute(IExecutorState state, ExecutorDelegate next, CancellationToken cancellationToken)\n    {\n        var context = state.FindContext&lt;ExecuteLinqExecuteContext&gt;();\n        // Early return if no ExecuteLinqExecuteContext set\n        if (context == null)\n        {\n            await next(state, cancellationToken);\n            return;\n        }\n\n        var queryable = context.Queryable;\n        var countQueryable = context.CountQueryable;\n\n        // Query the data\n        state.Data = await EntityFrameworkQueryableExtensions.ToListAsync((dynamic)queryable, cancellationToken);\n\n        // Count the data if necessary\n        if (countQueryable != null)\n        {\n            int totalCount = await EntityFrameworkQueryableExtensions.CountAsync(\n                (dynamic)countQueryable,\n                cancellationToken\n            );\n            state.SetTotalCount(totalCount);\n        }\n\n        // This is the last step that executes the request, so don't call next\n    }\n}\n</code></pre>"},{"location":"integrations/efcore/#2-add-extension-method","title":"2. Add extension method","text":"<p>To simplify integration, create an extension method to include the EF Core optimizations:</p> <pre><code>/// &lt;summary&gt;\n/// Extensions related to &lt;see cref=\"IExecuteConfigBuilder\"/&gt; and &lt;see cref=\"Microsoft.EntityFrameworkCore\"/&gt;.\n/// &lt;/summary&gt;\npublic static class ExecuteConfigBuilderEntityFrameworkCoreExtensions\n{\n    /// &lt;summary&gt;\n    /// Adds the &lt;see cref=\"EntityFrameworkCoreExecuteLinqExecutionHandler\"/&gt; to given &lt;paramref name=\"builder\"/&gt; if not\n    /// yet added.\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"builder\"&gt;Builder to configure.&lt;/param&gt;\n    /// &lt;returns&gt;The builder to continue building.&lt;/returns&gt;\n    public static IExecuteConfigBuilder WithEntityFrameworkCoreExecuteLinqExecutionHandler(\n        this IExecuteConfigBuilder builder\n    )\n    {\n        // Lazy provider so handler is only created when executing\n        IExecutionHandler? handler = null;\n        return builder.WithExecutionHandler(\n            EntityFrameworkCoreExecuteLinqExecutionHandler.DefaultName,\n            _ =&gt; handler ??= new EntityFrameworkCoreExecuteLinqExecutionHandler(),\n            EntityFrameworkCoreExecuteLinqExecutionHandler.DefaultOrder\n        );\n    }\n}\n</code></pre>"},{"location":"integrations/efcore/#3-configure-schema","title":"3. Configure Schema","text":"<p>Finally, update your schema to include the custom EF Core execution handler:</p> <pre><code>public sealed class ApiSchema : Schema { \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) {                 \n        schema.AddExecuteFeature(it =&gt;\n        {\n            // Add the EntityFrameworkCoreExecuteLinqExecutionHandler so specific EF Core methods are used \n            it.WithEntityFrameworkCoreExecuteLinqExecutionHandler();\n        });\n    }\n}\n</code></pre> <p>That's it, FunQL will now directly use EF Core's async methods when executing queries.</p>"},{"location":"integrations/newtonsoftjson/","title":"Newtonsoft.Json","text":"<p>Work in Progress</p> <p>We are actively working on the documentation for FunQL .NET. Please check back later or visit our repository to track progress or contribute.</p>"},{"location":"integrations/nodatime/","title":"NodaTime","text":"<p>Noda Time is a great alternative date and time API for .NET. However, integrating NodaTime with FunQL requires additional configuration to handle JSON serialization and support FunQL's DateTime functions, such as  <code>year()</code>, <code>month()</code>, and <code>day()</code>.</p> <p>You can also refer to the WebApi sample for a  practical example of the NodaTime integration.</p>"},{"location":"integrations/nodatime/#configuring-json-serialization","title":"Configuring JSON serialization","text":"<p>To handle NodaTime types (<code>Instant</code>, <code>LocalDate</code>, <code>LocalDateTime</code>), you must configure JSON serialization. FunQL uses  <code>System.Text.Json</code> by default, and the easiest way to add support for NodaTime types is through the  NodaTime.Serialization.SystemTextJson library.</p>"},{"location":"integrations/nodatime/#1-install-the-package","title":"1. Install the package","text":"<p>Run the following command to add the NodaTime.Serialization.SystemTextJson library:</p> <pre><code>dotnet add package NodaTime.Serialization.SystemTextJson\n</code></pre>"},{"location":"integrations/nodatime/#2-configure-json-for-nodatime","title":"2. Configure JSON for NodaTime","text":"<p>Update your <code>Schema</code> to include a custom <code>JsonSerializerOptions</code> configuration with NodaTime support:</p> <pre><code>public sealed class ApiSchema : Schema { \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) {     \n        // Create custom JsonSerializerOptions for FunQL\n        var jsonSerializerOptions = new JsonSerializerOptions() \n            // Add support for NodaTime types\n            .ConfigureForNodaTime(DateTimeZoneProviders.Tzdb);\n\n        // Apply the configured JsonSerializerOptions to FunQL\n        schema.JsonConfig()\n            .WithJsonSerializerOptions(jsonSerializerOptions);\n    }\n}\n</code></pre> <p>This ensures that NodaTime types are correctly serialized and deserialized when interacting with FunQL.</p>"},{"location":"integrations/nodatime/#supporting-datetime-functions","title":"Supporting DateTime functions","text":"<p>FunQL's built-in DateTime functions (<code>year()</code>, <code>month()</code>, <code>day()</code>) only work with .NET's <code>DateTime</code> type by default. To  enable these functions for NodaTime's <code>Instant</code> type, we need to add a custom translator.</p>"},{"location":"integrations/nodatime/#1-create-instant-translator","title":"1. Create Instant translator","text":"<p>Implement a custom <code>FieldFunctionLinqTranslator</code> that converts NodaTime's <code>Instant</code> to .NET's <code>DateTime</code>. This makes the  FunQL DateTime functions compatible with NodaTime types:</p> <pre><code>/// &lt;summary&gt;Translator for &lt;see cref=\"Instant\"/&gt; functions.&lt;/summary&gt;\n/// &lt;remarks&gt;\n/// Translates &lt;see cref=\"Instant\"/&gt; to &lt;see cref=\"DateTime\"/&gt; and then delegates the translation logic to\n/// &lt;see cref=\"DateTimeFunctionLinqTranslator\"/&gt;, so e.g. &lt;see cref=\"Year\"/&gt; and &lt;see cref=\"Month\"/&gt; field functions can\n/// be used on &lt;see cref=\"Instant\"/&gt; types.\n/// &lt;/remarks&gt;\npublic class InstantFunctionLinqTranslator : FieldFunctionLinqTranslator\n{\n    /// &lt;summary&gt;Empty &lt;see cref=\"Instant\"/&gt; we can use to get &lt;see cref=\"MethodInfo\"/&gt;.&lt;/summary&gt;\n    // ReSharper disable once RedundantDefaultMemberInitializer\n    private static readonly Instant DefaultInstant = default;\n    /// &lt;summary&gt;The &lt;see cref=\"MethodInfo\"/&gt; for &lt;see cref=\"Instant.ToDateTimeUtc\"/&gt;.&lt;/summary&gt;\n    private static readonly MethodInfo InstantToDateTimeUtcMethod =\n        MethodInfoUtil.MethodOf(DefaultInstant.ToDateTimeUtc);\n\n    /// &lt;summary&gt;The &lt;see cref=\"DateTime\"/&gt; translator to delegate translation logic to.&lt;/summary&gt;\n    private static readonly DateTimeFunctionLinqTranslator DateTimeFunctionLinqTranslator = new();\n\n    /// &lt;inheritdoc/&gt;\n    public override Expression? Translate(FieldFunction node, Expression source, ILinqVisitorState state)\n    {\n        if (source.Type.UnwrapNullableType() != typeof(Instant))\n            return null;\n\n        // Translate Instant to DateTime so we can use DateTime methods instead\n        source = LinqExpressionUtil.CreateFunctionCall(\n            InstantToDateTimeUtcMethod,\n            state.HandleNullPropagation,\n            source\n        );\n\n        return DateTimeFunctionLinqTranslator.Translate(node, source, state);\n    }\n}\n</code></pre>"},{"location":"integrations/nodatime/#2-add-extension-method","title":"2. Add extension method","text":"<p>To simplify adding NodaTime support to FunQL, create an extension method for the LINQ configuration:</p> <pre><code>/// &lt;summary&gt;Extensions related to &lt;see cref=\"ILinqConfigBuilder\"/&gt; and &lt;see cref=\"NodaTime\"/&gt;.&lt;/summary&gt;\npublic static class LinqConfigBuilderNodaTimeExtensions\n{\n    /// &lt;summary&gt;\n    /// Adds the &lt;see cref=\"InstantFunctionLinqTranslator\"/&gt; to given &lt;paramref name=\"builder\"/&gt; if not yet added.\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"builder\"&gt;Builder to configure.&lt;/param&gt;\n    /// &lt;returns&gt;The builder to continue building.&lt;/returns&gt;\n    public static ILinqConfigBuilder WithInstantFunctionLinqTranslator(\n        this ILinqConfigBuilder builder\n    )\n    {\n        // Early return if translator already added\n        if (builder.MutableConfig.GetFieldFunctionLinqTranslators().Any(it =&gt; it is InstantFunctionLinqTranslator))\n            return builder;\n\n        builder.MutableConfig.AddFieldFunctionLinqTranslator(new InstantFunctionLinqTranslator());\n\n        return builder;\n    }\n}\n</code></pre>"},{"location":"integrations/nodatime/#3-configure-schema","title":"3. Configure Schema","text":"<p>Finally, update your schema to include the custom translator for NodaTime's <code>Instant</code>:</p> <pre><code>public sealed class ApiSchema : Schema { \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) {         \n        schema.AddLinqFeature(it =&gt;\n        {\n            // Add DateTime function support for NodaTime Instant\n            it.WithInstantFunctionLinqTranslator();\n        });\n    }\n}\n</code></pre> <p>That's it, you can now use FunQL's DateTime functions on <code>Instant</code> types.</p>"}]}