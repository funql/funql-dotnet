{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#complex-queries-made-simple","title":"Complex queries made simple","text":"<p>FunQL .NET is the official .NET implementation of FunQL, the open-source Functional Query Language. It provides a simple way to add powerful query capabilities to existing REST APIs or build standalone FunQL APIs.</p> <p>With FunQL .NET, you can:</p> <ul> <li>Enhance existing REST APIs with ready-to-use components for filtering, sorting, pagination, and more.</li> <li>Build standalone FunQL APIs that harness the full power of the FunQL Query Language.</li> <li>Integrate with LINQ and EF Core to transform FunQL queries into efficient database queries.</li> </ul> <p>FunQL .NET is designed to be lightweight, efficient, and easy to integrate, giving developers full control over API behavior without unnecessary complexity. We continuously improve FunQL .NET to support new use cases and enhance developer experience.</p> <p>Let's get started with FunQL .NET!</p> <p>Get started Learn more</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>This guide will help you get started with FunQL .NET quickly.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#1-create-a-new-web-api-project","title":"1. Create a new Web API project","text":"<p>Create a new ASP.NET Core Web API project using the .NET CLI.</p> <pre><code>dotnet new webapi -n Demo\n</code></pre> <p>This will create a new directory called <code>Demo</code> containing your project's files.</p> <p>You can now open the <code>Demo</code> directory or the <code>Demo.csproj</code> file in your favourite code editor.</p>"},{"location":"getting-started/#2-add-the-funql-package","title":"2. Add the FunQL package","text":"<p>Add the FunQL  package to your  project using the .NET CLI:</p> <pre><code>dotnet add package FunQL\n</code></pre> <p>Note</p> <p>This will install both FunQL.Core and FunQL.Linq, providing all the essential components to get you started quickly.</p>"},{"location":"getting-started/#create-the-data-model","title":"Create the data model","text":"<p>For this example we'll create an API for querying LEGO sets, so create a <code>Set</code> data model.</p> <pre><code>public sealed record Set(string Name, double Price, DateTime LaunchTime);\n</code></pre>"},{"location":"getting-started/#create-the-schema","title":"Create the schema","text":"<p>A schema defines the structure and behavior of your API, including the available requests, their parameters, and the  data models they operate on. Create a schema and add the <code>Core</code> and <code>LINQ</code> features to enable query parsing, validation,  and execution. Then add the <code>listSets</code> request with support for filtering and sorting, ready to query <code>Set</code> data.</p> <pre><code>public sealed class DemoSchema : Schema\n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    {\n        // ===== Features =====\n        // Add all core features: Parse, Print, Validate, Visit and Execute\n        schema.AddCoreFeatures();\n        // Add LINQ feature so FunQL can translate FunQL queries to LINQ expressions, e.g. for use with EFCore DbSet\n        schema.AddLinqFeature();\n\n        // ===== Requests =====\n        // Add the 'listSets()' request\n        schema.Request(\"listSets\")\n            // Enable support for the 'filter()' parameter\n            .SupportsFilter()\n            // Enable support for the 'sort()' parameter\n            .SupportsSort()\n            // Configure the 'listSets()' return type: 'List&lt;Set&gt;'\n            .ReturnsListOfObjects&lt;Set&gt;(set =&gt;\n            {\n                // Configure each field of the data model\n                set.SimpleField(it =&gt; it.Name)\n                    .HasName(\"name\")\n                    .SupportsFilter(it =&gt; it.SupportsStringFilterFunctions())\n                    .SupportsSort(it =&gt; it.SupportsStringFieldFunctions());\n                set.SimpleField(it =&gt; it.Price)\n                    .HasName(\"price\")\n                    .SupportsFilter(it =&gt; it.SupportsDoubleFilterFunctions())\n                    .SupportsSort(it =&gt; it.SupportsDoubleFieldFunctions());\n                set.SimpleField(it =&gt; it.LaunchTime)\n                    .HasName(\"launchTime\")\n                    .SupportsFilter(it =&gt; it.SupportsDateTimeFilterFunctions())\n                    .SupportsSort(it =&gt; it.SupportsDateTimeFieldFunctions());\n            });\n    }\n}\n</code></pre>"},{"location":"getting-started/#add-funql-services","title":"Add FunQL services","text":"<p>In <code>Program.cs</code>, add the <code>DemoSchema</code> as a singleton to the application services, ready to be injected in request  handlers.</p> <pre><code>var builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddSingleton&lt;DemoSchema&gt;();\n</code></pre>"},{"location":"getting-started/#create-a-rest-endpoint-with-funql-support","title":"Create a REST endpoint with FunQL support","text":"<p>With the <code>DemoSchema</code> fully configured, we can use it to create a REST endpoint to filter and sort LEGO sets. Update  <code>Program.cs</code> to add the <code>/sets</code> endpoint to filter and sort a list of LEGO sets.  </p> <pre><code>app.MapGet(\"/sets\", async (string filter, string sort, DemoSchema schema) =&gt;\n{\n    // We use demo data for this example \u2014 Normally you would e.g. use an Entity Framework Core DbContext to query the \n    // database directly\n    IQueryable&lt;Set&gt; sets = new List&lt;Set&gt;\n    {\n        new(\"LEGO Star Wars Millennium Falcon\", 849.99, DateTime.Parse(\"2017-10-01\", styles: DateTimeStyles.AdjustToUniversal)),\n        new(\"LEGO Star Wars The Razor Crest\", 599.99, DateTime.Parse(\"2022-10-03\", styles: DateTimeStyles.AdjustToUniversal)),\n        new(\"LEGO DC Batman Batmobile Tumbler\", 269.99, DateTime.Parse(\"2021-11-01\", styles: DateTimeStyles.AdjustToUniversal)),\n        new(\"LEGO Harry Potter Hogwarts Castle\", 469.99, DateTime.Parse(\"2018-09-01\", styles: DateTimeStyles.AdjustToUniversal)),\n    }.AsQueryable();\n\n    var result = await sets\n        .ExecuteRequestForParameters(\n            schema, \n            requestName: \"listSets\", \n            filter: filter, \n            sort: sort\n        );\n\n    return result.Data;\n});\n</code></pre> <p>And that is it, you have now successfully added FunQL support to your API! \ud83d\ude80</p>"},{"location":"getting-started/#execute-a-query","title":"Execute a query","text":"<p>Run the project using the .NET CLI:</p> <pre><code>dotnet run\n</code></pre> <p>If everything is set up correctly, you should be able to open http://localhost:5000/sets  to query the LEGO sets. Looking for LEGO Star Wars sets that cost at least \u20ac500 and were launched after 2010, sorted by price? Just ask:</p> <pre><code>http://localhost:5000/sets\n    ?filter=and(has(upper(name), \"STAR WARS\"), gte(price, 500), gt(year(launchTime), 2010))\n    &amp;sort=desc(price)\n</code></pre>"},{"location":"additional-resources/design-philosophy/","title":"FunQL .NET design philosophy","text":"<p>Before you start using FunQL .NET, it's helpful to understand the design principles behind it. Our goal is to provide developers with the right tools to build powerful, flexible APIs in a way that's both intuitive and easy to use.</p> <p>To learn more about FunQL, visit funql.io.</p>"},{"location":"additional-resources/design-philosophy/#everything-you-would-expect","title":"Everything you would expect","text":"<p>FunQL .NET is designed with simplicity and efficiency in mind. We focus on providing the core functionalities that are essential to most API workflows while ensuring a smooth and seamless developer experience.</p> <ul> <li> <p> It just works</p> <p>FunQL .NET processes raw text into functional queries, handling lexical analysis, tokenization, syntax parsing, and Abstract Syntax Tree (AST) generation so you don't have to.</p> </li> <li> <p> Supports LINQ and EF Core</p> <p>Translates FunQL queries into LINQ expressions for seamless database interaction with EF Core.</p> </li> <li> <p> Zero dependencies</p> <p>Requires only .NET Core; no additional frameworks or external libraries needed.</p> </li> <li> <p> Built-in validation</p> <p>Enforces query parameter constraints, ensuring valid API queries.</p> </li> </ul>"},{"location":"additional-resources/design-philosophy/#built-for-developers-by-developers","title":"Built for developers, by developers","text":"<p>FunQL .NET is built with developers in mind. We believe in keeping things transparent, customizable, and flexible. It's designed to be simple, yet adaptable to meet the unique needs of any project.</p> <ul> <li> <p> Explicit by default</p> <p>No hidden behaviors or 'automagic' configurations. FunQL .NET enforces explicit schema definitions, giving developers full control and clarity over API behavior.</p> </li> <li> <p> Highly extensible</p> <p>Every component is customizable: override, extend, or replace parts to fit your project's needs.</p> </li> <li> <p> Configurable JSON serialization</p> <p>Works out of the box with <code>System.Text.Json</code> and supports external JSON libraries like <code>NewtonSoft.Json</code> for greater flexibility.</p> </li> <li> <p> Easy integration</p> <p>Install via NuGet for a seamless setup.</p> </li> </ul>"},{"location":"additional-resources/licensing/","title":"Licensing","text":"<p>FunQL .NET is available under two licensing options: the GPLv2 license for open-source use and a Commercial license for proprietary, closed-source use.</p> <p>Each option is designed to meet different needs. Visit funql.io to find out which license is right for your project.</p> <p>Learn more</p>"},{"location":"defining-a-schema/","title":"Defining a Schema","text":"<p>A <code>Schema</code> in FunQL .NET serves as the core configuration and entry point for processing FunQL queries. It defines what  data can be queried and which query options are supported (filtering, sorting, pagination). </p> <p>This guide walks you through building a schema and configuring it to handle FunQL requests.</p>"},{"location":"defining-a-schema/#implementing-the-schema","title":"Implementing the Schema","text":"<p>To get started, create a class that inherits from FunQL's <code>Schema</code> and override the <code>OnInitializeSchema()</code> method. This  method is where you configure your schema, including supported features and requests:</p> <pre><code>public sealed class ApiSchema : Schema\n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    {\n        // Schema configuration goes here\n    }\n}\n</code></pre> <p>Note</p> <p>While it's usually enough to implement <code>OnInitializeSchema(ISchemaConfigBuilder)</code>, you may also implement  <code>OnFinalizeSchema(ISchemaConfigBuilder)</code>, which can be used for additional customizations, like modifying default  settings or applying conventions.</p> <p>FunQL schemas prioritize explicit configurations, providing developers with complete control and predictability. There  are no hidden behaviors or 'automagic' configurations \u2014 every feature and setting must be explicitly defined.</p>"},{"location":"defining-a-schema/#adding-features","title":"Adding features","text":"<p>Features define the capabilities of your schema, from parsing and validating FunQL queries to translating them into  LINQ expressions for execution.</p> <p>To get started quickly, add the most commonly used features:</p> <ul> <li>Core features: Enables common operations like parsing, query validation, and execution.</li> <li>LINQ feature: Translates FunQL queries into LINQ expressions, which is useful for querying in-memory collections    or external databases (e.g., using Entity Framework (EF) Core).</li> </ul> <pre><code>public sealed class ApiSchema : Schema\n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    {\n        // Add core parsing, validation and execution features\n        schema.AddCoreFeatures();\n        // Enable LINQ query translation\n        schema.AddLinqFeature();\n    }\n}\n</code></pre> <p>By adding only the features you need, you ensure that your schema remains lightweight and optimized for your use case.</p> <p>Learn more about features \u2192</p>"},{"location":"defining-a-schema/#adding-requests","title":"Adding requests","text":"<p>In FunQL, requests define the entry points to your data. They represent the operations that users can query, specifying  what data can be fetched and how it can be filtered or sorted.</p>"},{"location":"defining-a-schema/#key-concepts-of-requests","title":"Key concepts of requests","text":"<ol> <li>Request name: Each request has a unique identifier, like <code>listSets</code>, used in queries to specify the operation to     execute.</li> <li>Parameters: Requests specify which parameters they support, like the <code>filter()</code> and <code>sort()</code> parameters to     provide advanced querying capabilities.</li> <li>Return type: Requests define the type of data returned, such as a list of objects, along with the fields that can     be queried, filtered, and sorted.</li> </ol>"},{"location":"defining-a-schema/#example-request","title":"Example request","text":"<p>As an example, we'll configure a <code>listSets()</code> request with support for filtering and sorting a list of LEGO sets. Once  configured, the schema is ready to handle advanced FunQL queries like:</p> RESTQL <pre><code>GET http://localhost:5000/sets\n  ?filter=and(\n    has(upper(name), \"STAR WARS\"),\n    gte(price, 500),\n    gt(year(launchTime), 2010)\n  )\n  &amp;sort=desc(price)\n</code></pre> <pre><code>listSets(\n  filter(\n    and(\n      has(upper(name), \"STAR WARS\"),\n      gte(price, 500),\n      gt(year(launchTime), 2010)\n    )\n  ),\n  sort(\n    desc(price)\n  )\n)\n</code></pre>"},{"location":"defining-a-schema/#define-the-data-model","title":"Define the data model","text":"<p>Start by defining the <code>Set</code> data model, which represents the LEGO sets and serves as the return type of the <code>listSets()</code>  request:</p> <pre><code>public sealed record Set(string Name, double Price, DateTime LaunchTime);\n</code></pre> <p>The fields <code>Name</code>, <code>Price</code>, and <code>LaunchTime</code> will later be configured to support filtering and sorting.</p>"},{"location":"defining-a-schema/#add-the-request","title":"Add the request","text":"<p>Define the <code>listSets</code> request in the schema:</p> <pre><code>public sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {        \n        // Add the 'listSets' request \n        schema.Request(\"listSets\")\n            // Enable support for the 'filter()' parameter \n            .SupportsFilter()\n            // Enable support for the 'sort()' parameter \n            .SupportsSort()            \n            // Define the return type as a list of 'Set' objects (List&lt;Set&gt;)\n            .ReturnsListOfObjects&lt;Set&gt;(set =&gt;\n            {\n                // Field configurations go here\n            });\n    }\n}\n</code></pre> <p>At this point, the <code>listSets</code> request is defined and supports the <code>filter()</code> and <code>sort()</code> parameters. However, the  fields must be explicitly configured before they can be filtered and sorted on, so let's configure this next.</p> <p>Learn more about requests \u2192</p>"},{"location":"defining-a-schema/#configure-fields","title":"Configure fields","text":"<p>Fields define which properties of the data model can be queried, filtered, and sorted. Expose the <code>Set</code> properties  (<code>Name</code>, <code>Price</code>, and <code>LaunchTime</code>) for filtering and sorting:</p> <pre><code>public sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {\n        schema.Request(\"listSets\")\n            .SupportsFilter()\n            .SupportsSort()            \n            .ReturnsListOfObjects&lt;Set&gt;(set =&gt;\n            {\n                // Configure the 'Name' field\n                set.SimpleField(it =&gt; it.Name)\n                    // Override the default name ('Name') to use its JSON name\n                    .HasName(\"name\")\n                    // Enable support for filtering on this field\n                    .SupportsFilter(it =&gt; \n                        // Enable String functions like:\n                        // - has(name, \"War\")\n                        // - stw(upper(name), \"STAR\")\n                        it.SupportsStringFilterFunctions()\n                    )\n                    // Enable support for sorting on this field\n                    .SupportsSort(it =&gt; \n                        // Enable String functions like:\n                        // - asc(lower(name))\n                        // - desc(upper(name))\n                        it.SupportsStringFieldFunctions()\n                    );\n\n                set.SimpleField(it =&gt; it.Price)\n                    .HasName(\"price\")\n                    .SupportsFilter(it =&gt; \n                        // Enable Double functions like:\n                        // - eq(round(price), 100)\n                        it.SupportsDoubleFilterFunctions()\n                    )\n                    .SupportsSort(it =&gt; it.SupportsDoubleFieldFunctions());\n\n                set.SimpleField(it =&gt; it.LaunchTime)\n                    .HasName(\"launchTime\")\n                    .SupportsFilter(it =&gt;\n                        // Enable DateTime functions like:\n                        // - gte(year(launchTime), 2010)\n                        it.SupportsDateTimeFilterFunctions()\n                    )\n                    .SupportsSort(it =&gt; it.SupportsDateTimeFieldFunctions());\n            });\n    }\n}\n</code></pre> <p>The <code>Schema</code> is now fully configured and ready to handle <code>listSets</code> requests.</p> <p>Learn more about fields \u2192</p>"},{"location":"defining-a-schema/#next-steps","title":"Next steps","text":"<p>Now that you've learned how to define a schema, let's learn how to execute a query.</p>"},{"location":"defining-a-schema/requests/","title":"Requests","text":"<p>In FunQL, requests define the entry points to your data. They represent the operations that users can query, specifying what data can be fetched and how it can be filtered or sorted.</p> <p>This page explains how to define and configure requests.</p>"},{"location":"defining-a-schema/requests/#key-concepts-of-requests","title":"Key concepts of requests","text":"<ol> <li>Request name: Each request has a unique identifier, like <code>listSets</code>, used in queries to specify the operation to    execute.</li> <li>Parameters: Requests specify which parameters they support, like the <code>filter()</code> and <code>sort()</code> parameters to    provide advanced querying capabilities.</li> <li>Return type: Requests define the type of data returned, such as a list of objects, along with the fields that can    be queried, filtered, and sorted.</li> </ol>"},{"location":"defining-a-schema/requests/#adding-a-request","title":"Adding a request","text":"<p>Add a request by calling <code>schema.Request(string name)</code> in your <code>Schema</code> configuration.</p> <pre><code>public sealed class ApiSchema : Schema \n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    { \n        // Add the 'listSets' request \n        schema.Request(\"listSets\");\n    }\n}\n</code></pre> <p>With the <code>listSets</code> request defined, the schema can now be used to handle <code>listSets()</code> requests. However, the request does not yet support any parameters or defines the fields to query, so let's configure that next.</p>"},{"location":"defining-a-schema/requests/#supporting-parameters","title":"Supporting parameters","text":"<p>By default, a request does not support any parameters. You must explicitly enable parameters that are relevant to the request. For example, the <code>listSets</code> request should support common list operations like filtering, sorting, and  pagination:</p> <pre><code>public sealed class ApiSchema : Schema \n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    { \n        schema.Request(\"listSets\")\n            // Enable support for the 'filter()' parameter \n            .SupportsFilter()\n            // Enable support for the 'sort()' parameter \n            .SupportsSort()     \n            // Enable support for the 'skip()' parameter \n            .SupportsSkip()  \n            // Enable support for the 'limit()' parameter \n            .SupportsLimit();         \n    }\n}\n</code></pre> <p>You may pass an action to configure each parameter, for example, to define a default and maximum value for the <code>limit()</code>  parameter:</p> <pre><code>public sealed class ApiSchema : Schema \n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    { \n        schema.Request(\"listSets\")\n            .SupportsFilter()\n            .SupportsSort()     \n            .SupportsSkip()  \n            .SupportsLimit(config =&gt; \n            {\n                // Set the default limit to 10\n                config.HasDefaultValue(new Limit(new Constant(10))) \n                    // Set the maximum limit to 100\n                    .HasMaxLimit(100);                                \n            });         \n    }\n}\n</code></pre> <p>When executing a request, it will now ensure that the <code>limit()</code> parameter is not greater than <code>100</code> and it will use the  default value of <code>10</code> if no limit was given.</p> <p>Learn more about parameters \u2192</p>"},{"location":"defining-a-schema/requests/#defining-fields","title":"Defining fields","text":"<p>With the parameters configured, the request can now be used to query data. However, it does not yet define which fields  can be queried, filtered, and sorted. For this, you must specify the return type of the request:</p> <pre><code>public sealed class ApiSchema : Schema \n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    { \n        schema.Request(\"listSets\")\n            .SupportsFilter()\n            .SupportsSort()     \n            .SupportsSkip()  \n            .SupportsLimit()\n            .ReturnsListOfObjects&lt;Set&gt;(set =&gt;\n            {\n                // Field configurations go here, for example:\n                set.SimpleField(it =&gt; it.Price)\n                    .HasName(\"price\")\n                    .SupportsFilter(it =&gt; it.SupportsDoubleFilterFunctions())\n                    .SupportsSort(it =&gt; it.SupportsDoubleFieldFunctions());\n            });\n    }\n}\n</code></pre> <p>This configures <code>listSets</code> to return a list of <code>Set</code> objects, with a <code>price</code> field that supports filtering and sorting.  With all this configured, the request is now properly configured to handle queries like:</p> RESTQL <pre><code>GET http://localhost:5000/sets\n  ?filter=gte(price, 500)\n  &amp;sort=desc(price)\n</code></pre> <pre><code>listSets(\n  filter(\n    gte(price, 500)\n  ),\n  sort(\n    desc(price)\n  )\n)\n</code></pre> <p>Learn more about configuring fields \u2192</p>"},{"location":"defining-a-schema/requests/#whats-next","title":"What's next","text":"<p>With the request configured, you can now execute queries with it. Or continue to configure the request to support  additional parameters and fields.</p> <ul> <li>Learn more about executing queries \u2192</li> <li>Learn more about parameters \u2192</li> <li>Learn more about fields \u2192</li> </ul>"},{"location":"defining-a-schema/features/","title":"Features","text":"<p>FunQL provides a modular architecture where each capability (like parse, validate, execute) is its own configurable feature. By only including the features you need, you ensure that your schema remains lightweight and optimized for your use case.</p> <p>This section introduces FunQL's features, explains their role, and shows you how to add them to your schema.</p>"},{"location":"defining-a-schema/features/#adding-core-features","title":"Adding core features","text":"<p>To quickly enable all core features (Parse, Validate, Execute, Print, and Visit), use:</p> <pre><code>public sealed class ApiSchema : Schema\n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    {\n        schema.AddCoreFeatures();\n    }\n}\n</code></pre> <p>For a lightweight schema, selectively add only the features you need.</p>"},{"location":"defining-a-schema/features/#parse","title":"Parse","text":"<p>The parse feature enables FunQL to transform raw queries into structured query nodes by generating an Abstract Syntax  Tree (AST). This is the first step in handling FunQL queries before validation or execution.</p> <p>Adding the feature:</p> <pre><code>public sealed class ApiSchema : Schema\n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    {\n        schema.AddParseFeature();\n    }\n}\n</code></pre> <p>Learn more about the parse feature \u2192</p>"},{"location":"defining-a-schema/features/#validate","title":"Validate","text":"<p>The validate feature allows for validating that FunQL queries comply with the rules defined in the schema. This prevents  invalid queries from being processed by catching errors early.</p> <p>Adding the feature:</p> <pre><code>public sealed class ApiSchema : Schema\n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    {\n        schema.AddValidateFeature();\n    }\n}\n</code></pre> <p>Learn more about the validate feature \u2192</p>"},{"location":"defining-a-schema/features/#execute","title":"Execute","text":"<p>The execute feature simplifies the entire query-processing pipeline by combining parsing, validation, and execution into a single method, leveraging FunQL's execution pipeline.</p> <p>Adding the feature:</p> <pre><code>public sealed class ApiSchema : Schema\n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    {\n        schema.AddExecuteFeature();\n    }\n}\n</code></pre> <p>Learn more about the execute feature \u2192</p>"},{"location":"defining-a-schema/features/#linq","title":"LINQ","text":"<p>The LINQ feature translates FunQL queries into LINQ expressions, enabling seamless integration with LINQ-based frameworks such as Entity Framework Core.</p> <p>Adding the feature:</p> <pre><code>public sealed class ApiSchema : Schema\n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    {\n        schema.AddLinqFeature();\n    }\n}\n</code></pre> <p>Learn more about the LINQ feature \u2192</p>"},{"location":"defining-a-schema/features/#visit","title":"Visit","text":"<p>The visit feature provides functionality to traverse and inspect the FunQL AST. It is commonly used for the validate feature, but it can be extended for custom operations like query rewriting or auditing.</p> <p>Adding the feature:</p> <pre><code>public sealed class ApiSchema : Schema\n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    {\n        schema.AddVisitFeature();\n    }\n}\n</code></pre> <p>Learn more about the visit feature \u2192</p>"},{"location":"defining-a-schema/features/#print","title":"Print","text":"<p>The print feature converts the FunQL AST into a readable FunQL query string. This is useful for logging or debugging complex queries.</p> <p>Adding the feature:</p> <pre><code>public sealed class ApiSchema : Schema\n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    {\n        schema.AddPrintFeature();\n    }\n}\n</code></pre> <p>Learn more about the print feature \u2192</p>"},{"location":"defining-a-schema/features/execute/","title":"Execute","text":"<p>The execute feature wires together parsing, validation, and execution so you can run FunQL requests end-to-end with a single call. It builds on the execution pipeline, ensuring that all steps are performed in the correct order and in the  right way, reducing complexity for developers.</p> <p>This page explains how to enable the execute feature, how to run requests, and how to customize the pipeline.</p>"},{"location":"defining-a-schema/features/execute/#adding-the-feature","title":"Adding the feature","text":"<p>Use <code>AddExecuteFeature()</code> to register the services required to execute FunQL requests:</p> <pre><code>public sealed class ApiSchema : Schema \n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    { \n        schema.AddExecuteFeature();\n    }\n}\n</code></pre> <p>This sets up the execute feature with default configurations and the core execution handlers, like handlers for parsing  and validating. See Advanced configuration on how to customize the feature.</p>"},{"location":"defining-a-schema/features/execute/#executing-requests","title":"Executing requests","text":"<p>To avoid duplication, the examples for executing FunQL requests (both REST-style parameters and full FunQL queries) are  documented in the Executing queries guide:</p> <ul> <li>Learn how to execute requests \u2192</li> </ul>"},{"location":"defining-a-schema/features/execute/#advanced-configuration","title":"Advanced configuration","text":"<p>The <code>AddExecuteFeature()</code> method has two optional arguments:</p> <ul> <li><code>action</code>: An action to customize the feature.</li> <li><code>withCoreExecutionHandlers</code>: Whether to add all core execution handlers. Default <code>true</code>.</li> </ul> <p>For example, add your own execution handler:</p> <pre><code>public sealed class ApiSchema : Schema \n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    { \n        schema.AddExecuteFeature(config =&gt; { \n            // Customize the feature here            \n            config.WithExecutionHandler(\"MyCustomHandler\", new MyCustomHandler(), 0);\n        });\n    }\n}\n</code></pre>"},{"location":"defining-a-schema/features/execute/#core-execution-handlers","title":"Core execution handlers","text":"<p>With <code>withCoreExecutionHandlers</code> set to <code>true</code> (default), the execute feature adds the following core execution  handlers:</p> <ul> <li><code>ParseRequestExecutionHandler</code>: Parses a full FunQL request string (e.g., <code>listSets(skip(1))</code>) into a <code>Request</code>    AST for further processing. This is designed for full FunQL queries, treating FunQL as a query language (QL).</li> <li><code>ParseRequestForParametersExecutionHandler</code>: Builds a <code>Request</code> from given parameters (e.g., <code>filter</code>, <code>sort</code>),    parsing each parameter separately. This is designed for REST APIs where the FunQL parameters are extracted from the    URL, like  <code>../sets?filter=gte(price, 500)&amp;sort=desc(price)</code>.</li> <li><code>ValidateRequestExecutionHandler</code>: Validates the parsed <code>Request</code> against the schema.</li> </ul> <p>Tip</p> <p>Add the LINQ feature after the execute feature to automatically register the LINQ execution handlers.  These handlers translate the <code>Request</code> into LINQ and apply filter/sort/limit/skip to the target <code>IQueryable</code>.</p>"},{"location":"defining-a-schema/features/execute/#custom-execution-handlers","title":"Custom execution handlers","text":"<p>You can also add your own execution handlers to the pipeline. For example, a handler that measures the time it takes to  execute the request:</p> <pre><code>public sealed class TimingExecutionHandler : IExecutionHandler \n{     \n    public async Task Execute(IExecutorState state, ExecutorDelegate next, CancellationToken cancellationToken)\n    {\n        var stopwatch = Stopwatch.StartNew();\n        try\n        {\n            await next(state, cancellationToken);\n        }\n        finally\n        {\n            stopwatch.Stop();\n            Console.WriteLine($\"Request executed in {stopwatch.ElapsedMilliseconds} ms\");\n        }\n    }\n}\n</code></pre> <p>Then register the handler when adding the execute feature:</p> <pre><code>public sealed class ApiSchema : Schema \n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    { \n        schema.AddExecuteFeature(config =&gt; { \n            // Register the handler here      \n            config.WithExecutionHandler(\n                // Name of the handler, used to identify it in the pipeline\n                name: \"TimingExecutionHandler\", \n                new TimingExecutionHandler(), \n                // Lower order means earlier in the pipeline, so pick a very \n                // low value to measure the whole pipeline \n                order: int.MinValue\n            );\n        });\n    }\n}\n</code></pre> <p>Now whenever a request is executed, the <code>TimingExecutionHandler</code> will log how long it takes to execute the request.</p> <p>Dynamic context:</p> <p>For handlers that require dynamic context or need to share data with other handlers, use <code>IExecutorState</code> to enter an  <code>IExecuteContext</code>. This stores data that handlers later in the pipeline can then use.</p> <p>As an example, we update the <code>TimingExecutionHandler</code> to enter a <code>TimingContext</code> with a shared <code>Stopwatch</code> for a  different handler to use:</p> <pre><code>public sealed record TimingContext(Stopwatch Stopwatch) : IExecuteContext;\n\npublic sealed class TimingExecutionHandler : IExecutionHandler \n{     \n    public async Task Execute(IExecutorState state, ExecutorDelegate next, CancellationToken cancellationToken)\n    {\n        var stopwatch = Stopwatch.StartNew();\n        // Enter the context before calling the next handler\n        state.EnterContext(new TimingContext(stopwatch));\n\n        await next(state, cancellationToken);\n\n        // Exit the context to clean up the data\n        state.ExitContext();\n    }\n}\n</code></pre> <p>Now create a handler that uses the <code>TimingContext</code> to log the elapsed time:</p> <pre><code>public sealed class LogTimingExecutionHandler : IExecutionHandler \n{     \n    public Task Execute(IExecutorState state, ExecutorDelegate next, CancellationToken cancellationToken)\n    {\n        // Find the context and log the elapsed time\n        var context = state.FindContext&lt;TimingContext&gt;();\n        if (context != null) {\n            Console.WriteLine($\"Time elapsed is {context.stopwatch.ElapsedMilliseconds} ms\");\n        } // else: Context was not entered\n\n        return next(state, cancellationToken);\n    }\n}\n</code></pre> <p>The <code>LogTimingExecutionHandler</code> logs the elapsed time only when a <code>TimingContext</code> has been entered.</p>"},{"location":"defining-a-schema/features/execute/#whats-next","title":"What's next","text":"<p>With the execution feature added, it's time to use it:</p> <ul> <li>Learn more about executing queries \u2192</li> <li>Learn more about the LINQ feature \u2192</li> </ul>"},{"location":"defining-a-schema/features/linq/","title":"LINQ","text":"<p>The LINQ feature translates FunQL requests into LINQ expressions so they can be applied to <code>IQueryable&lt;T&gt;</code> sources. This enables seamless integration with in-memory collections and LINQ-based frameworks such as Entity Framework Core.</p> <p>This page explains how to enable the LINQ feature, how to apply translations, and how to customize it.</p>"},{"location":"defining-a-schema/features/linq/#adding-the-feature","title":"Adding the feature","text":"<p>Use <code>AddLinqFeature()</code> to register services that can translate FunQL nodes (filter, sort, skip, limit) into LINQ expressions:</p> <pre><code>public sealed class ApiSchema : Schema \n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    { \n        // Adds translators for filter/sort/skip/limit \n        schema.AddLinqFeature(); \n    } \n}\n</code></pre> <p>This sets up the LINQ feature with default configurations. See Advanced configuration on how  to customize the feature.</p> <p>Tip</p> <p>If you already added the Execute feature, adding the LINQ feature will automatically register the LINQ  execution handlers by default.</p>"},{"location":"defining-a-schema/features/linq/#applying-translations","title":"Applying translations","text":"<p>Once the LINQ feature is added, you can apply FunQL parameters directly to an <code>IQueryable&lt;T&gt;</code>:</p> <ul> <li><code>IQueryable.ApplyFilter()</code>: Applies a FunQL <code>Filter</code>.</li> <li><code>IQueryable.ApplySort()</code>: Applies a FunQL <code>Sort</code>.</li> <li><code>IQueryable.ApplySkip()</code>: Applies a FunQL <code>Skip</code>.</li> <li><code>IQueryable.ApplyLimit()</code>: Applies a FunQL <code>Limit</code>.</li> <li><code>IQueryable.ApplyRequest()</code>: Applies the FunQL <code>Filter</code>, <code>Sort</code>, <code>Skip</code>, and <code>Limit</code> for given <code>Request</code>.</li> </ul> <p>Tip</p> <p>It's recommended to use the Execute feature instead of manually applying FunQL parameters. See  Executing requests for more information.</p> <p>The easiest way to apply FunQL parameters to an <code>IQueryable&lt;T&gt;</code> is to use <code>ApplyRequest()</code>:</p> <pre><code>// Define the data model\npublic sealed record Set(string Name, double Price, DateTime LaunchTime);\n\n// Prepare in-memory data\nvar sets = new List&lt;Set&gt;\n{\n    new(\"LEGO Star Wars Millennium Falcon\", 849.99, new DateTime(2017, 10, 01)),\n    new(\"LEGO Star Wars The Razor Crest\", 599.99, new DateTime(2022, 10, 03)),\n    new(\"LEGO DC Batman Batmobile Tumbler\", 269.99, new DateTime(2021, 11, 01)),\n    new(\"LEGO Harry Potter Hogwarts Castle\", 469.99, new DateTime(2018, 09, 01)),\n};\n\n// Create the configured schema\nvar schema = new ApiSchema();\n// Parse a FunQL request to apply to the sets\nvar request = schema.ParseRequest(@\"listSets(\n    filter(gte(price, 500)),\n    sort(desc(price)), \n    skip(1),\n    limit(5)\n)\");\n\n// Apply FunQL request to the IQueryable&lt;T&gt;\nvar results = sets.ApplyRequest(schema, request)\n    .ToList();\n\n// Print the result\nConsole.WriteLine(string.Join(\"\\n\", results));\n// Output:\n// Set { Name = LEGO Star Wars The Razor Crest, Price = 599,99, LaunchTime = 3-10-2022 00:00:00 }\n</code></pre> <p>You may also apply each parameter individually:</p> <pre><code>// Define the data model\npublic sealed record Set(string Name, double Price, DateTime LaunchTime);\n\n// Prepare in-memory data\nvar sets = new List&lt;Set&gt;\n{\n    new(\"LEGO Star Wars Millennium Falcon\", 849.99, new DateTime(2017, 10, 01)),\n    new(\"LEGO Star Wars The Razor Crest\", 599.99, new DateTime(2022, 10, 03)),\n    new(\"LEGO DC Batman Batmobile Tumbler\", 269.99, new DateTime(2021, 11, 01)),\n    new(\"LEGO Harry Potter Hogwarts Castle\", 469.99, new DateTime(2018, 09, 01)),\n};\n\n// FunQL parameters to apply\n// Example filter: filter(gte(price, 500))\nvar filter = new Filter(\n    new GreaterThanOrEqual( \n        new FieldPath([new NamedField(\"price\")]), \n        new Constant(500.00) \n    )\n);\n// Example sort: sort(desc(price))\nvar sort = new Sort([\n    new Descending(new FieldPath([new NamedField(\"price\")]))\n]);\n// Example skip: skip(1)\nvar skip = new Skip(new Constant(1));\n// Example limit: limit(5)\nvar limit = new Limit(new Constant(5));\n\n// Create the configured schema\nvar schema = new ApiSchema();\n\n// Apply parameters\nvar results = sets.ApplyFilter(schema.SchemaConfig, \"listSets\", filter) \n    // Setting alreadyOrdered to false as the sets are not ordered yet; When \n    // manually calling `.OrderBy()`, you need to set alreadyOrdered to true, \n    // so FunQL knows to use `.ThenBy()` instead of `.OrderBy()` \n    .ApplySort(schema.SchemaConfig, \"listSets\", sort, alreadyOrdered: false)\n    .ApplySkip(skip)\n    .ApplyLimit(limit)\n    .ToList();\n\n// Print the result\nConsole.WriteLine(string.Join(\"\\n\", results));\n// Output:    \n// Set { Name = LEGO Star Wars The Razor Crest, Price = 599,99, LaunchTime = 3-10-2022 00:00:00 }\n</code></pre>"},{"location":"defining-a-schema/features/linq/#executing-requests","title":"Executing requests","text":"<p>While you can apply FunQL parameters directly to an <code>IQueryable&lt;T&gt;</code>, it's recommended to use the execution pipeline instead. The execution pipeline will assure the FunQL parameters are applied in the correct order and the total count  (<code>count(true)</code>) is calculated before applying <code>skip</code> and <code>limit</code> parameters.</p> <ul> <li>Learn how to execute requests \u2192</li> </ul>"},{"location":"defining-a-schema/features/linq/#advanced-configuration","title":"Advanced configuration","text":"<p>The <code>AddLinqFeature()</code> method has two optional arguments:</p> <ul> <li><code>action</code>: An action to customize the feature.</li> <li><code>withLinqExecutionHandlers</code>: Whether to add all LINQ execution handlers. Default <code>true</code>.</li> </ul> <p>For example, add a custom field function LINQ translator (e.g., to support custom types like NodaTime's <code>Instant</code>):</p> <pre><code>public sealed class ApiSchema : Schema \n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    { \n        schema.AddLinqFeature(config =&gt; { \n            // Customize the feature here            \n            config.MutableConfig\n                .AddFieldFunctionLinqTranslator(new MyCustomLinqTranslator());\n        });\n    }\n}\n</code></pre> <p>Tip</p> <p>Using NodaTime in your application and want to use field functions like <code>year()</code> and <code>month()</code>? Check out the  NodaTime integration on how to support this:</p> <p>Learn how to integrate FunQL with NodaTime \u2192.</p>"},{"location":"defining-a-schema/features/linq/#whats-next","title":"What's next","text":"<p>After adding LINQ, it's time to execute queries on your database:</p> <ul> <li>Learn more about executing queries \u2192</li> <li>Learn more about integrating Entity Framework Core \u2192</li> </ul>"},{"location":"defining-a-schema/features/parse/","title":"Parse","text":"<p>The parse feature is crucial for transforming raw FunQL queries into structured query nodes by generating an Abstract  Syntax Tree (AST). Parsing is the first step in processing a FunQL query before it can be validated and executed. </p> <p>This page explains how to configure the parse feature and demonstrates how to parse queries.</p>"},{"location":"defining-a-schema/features/parse/#adding-the-feature","title":"Adding the feature","text":"<p>The <code>AddParseFeature()</code> method registers all services required for parsing FunQL requests. Use this to set up the parse  feature in your schema:</p> <pre><code>public sealed class ApiSchema : Schema\n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    {\n        schema.AddParseFeature();\n    }\n}\n</code></pre> <p>This sets up the parse feature with default configurations, making your schema capable of parsing raw FunQL requests.</p>"},{"location":"defining-a-schema/features/parse/#parsing-requests","title":"Parsing requests","text":"<p>Once the parse feature is added, the schema exposes two methods to parse FunQL requests depending on your use case:</p> <ol> <li><code>ParseRequestForParameters()</code>: Designed for REST APIs where FunQL parameters like <code>filter</code> and <code>sort</code> are    passed as URL query parameters.</li> <li><code>ParseRequest()</code>: Designed for full FunQL queries, treating FunQL as a query language (QL). This approach    combines all parameters into a single query.</li> </ol> RESTQL Example request<pre><code>GET http://localhost:5000/sets\n  ?filter=gte(price, 500)\n  &amp;sort=desc(price)\n</code></pre> <p>Parsing code:</p> <pre><code>// Get query parameters\nconst string filter = \"gte(price, 500)\";\nconst string sort = \"desc(price)\";\n\n// Create the configured schema\nvar schema = new ApiSchema();\n\n// Parse the request\nvar request = schema.ParseRequestForParameters(\n    requestName: \"listSets\", \n    filter: filter, \n    sort: sort\n);\n\n// Output (parsed AST):\n// new Request(\n//     Name: \"listSets\",\n//     Parameters: [\n//         new Filter(\n//             new GreaterThanOrEqual(\n//                 new FieldPath([new NamedField(\"price\")]),\n//                 new Constant(500)\n//             )\n//         ),\n//         new Sort([\n//             new Descending(new FieldPath([new NamedField(\"price\")]))\n//         ])\n//     ]\n// );\n</code></pre> <p>The <code>ParseRequestForParameters()</code> method is ideal for REST APIs. It will parse the <code>filter</code> and <code>sort</code> parameters  using the configuration for the <code>listSets</code> request. The result will be the parsed <code>Request</code>, which is the full AST,  ready for further processing like validation and execution.</p> Example request<pre><code>listSets(\n  filter(\n    gte(price, 500)\n  ),\n  sort(\n    desc(price)\n  )\n)\n</code></pre> <p>Parsing code:</p> <pre><code>// Get raw FunQL query\nconst string rawRequest = @\"listSets(\n  filter(\n    gte(price, 500)\n  ),\n  sort(\n    desc(price)\n  )\n)\";\n\n// Create the configured schema\nvar schema = new ApiSchema();\n\n// Parse the request\nvar request = schema.ParseRequest(rawRequest);\n\n// Output (parsed AST):\n// new Request(\n//     Name: \"listSets\",\n//     Parameters: [\n//         new Filter(\n//             new GreaterThanOrEqual(\n//                 new FieldPath([new NamedField(\"price\")]),\n//                 new Constant(500)\n//             )\n//         ),\n//         new Sort([\n//             new Descending(new FieldPath([new NamedField(\"price\")]))\n//         ])\n//     ]\n// );\n</code></pre> <p>The <code>ParseRequest()</code> method is designed for use cases where FunQL acts as a fully integrated query language. There's  no need to pass the <code>requestName</code>, as this is automatically resolved when parsing the request. The result will be  the parsed <code>Request</code>, which is the full AST, ready for further processing like validation and execution.</p> <p>Tip</p> <p>Use the execute feature to simplify query processing. It automates essential steps like parsing,  validation, LINQ translation, and data fetching, allowing you to handle complex FunQL queries with just a single  method call.</p>"},{"location":"defining-a-schema/features/parse/#advanced-configuration","title":"Advanced configuration","text":"<p>You can customize the parse feature by passing an action to the <code>AddParseFeature()</code> method. For example, replace the  default constant parser with your own:</p> <pre><code>public sealed class ApiSchema : Schema\n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    {\n        schema.AddParseFeature(config =&gt;\n        {\n            // Customize the parse feature here\n            config.WithConstantParserProvider(_ =&gt; new MyCustomConstantParser());\n        });\n    }\n}\n</code></pre> <p>Use this approach when you need to adjust or extend the behavior of the parsing services. </p> <p>Tip</p> <p>Using Newtonsoft.Json in your application? No problem! Simply replace the default JSON parser with your own  Newtonsoft.Json parser.</p> <p>Learn how to integrate FunQL with Newtonsoft.Json \u2192.</p>"},{"location":"defining-a-schema/features/parse/#whats-next","title":"What's next","text":"<p>Now that you have a fully parsed FunQL <code>Request</code>, ensure the query is valid:</p> <ul> <li>Learn more about the validate feature \u2192</li> </ul>"},{"location":"defining-a-schema/features/print/","title":"Print","text":"<p>The print feature converts a FunQL Abstract Syntax Tree (AST) back into a readable FunQL query string. It's especially useful for logging, debugging, or auditing.</p> <p>This page explains how to enable the print feature, how to print requests, and how to customize the feature.</p>"},{"location":"defining-a-schema/features/print/#adding-the-feature","title":"Adding the feature","text":"<p>Use <code>AddPrintFeature()</code> to register the services required to print FunQL ASTs:</p> <pre><code>public sealed class ApiSchema : Schema \n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {\n        schema.AddPrintFeature();\n    }\n}\n</code></pre> <p>This sets up the print feature with default configurations.</p>"},{"location":"defining-a-schema/features/print/#printing-requests","title":"Printing requests","text":"<p>Once the print feature is added, you can turn a parsed <code>Request</code> into a FunQL string.</p> <pre><code>var schema = new ApiSchema();\nvar request = schema.ParseRequest(\"listSets()\");\n\n// Get the request print visitor from the Schema\nvar requestPrintVisitor = schema.SchemaConfig.FindPrintConfigExtension()\n    .RequestPrintVisitorProvider(schema.SchemaConfig);\n\n// Create a string writer to which the AST will be printed\nvar stringWriter = new StringWriter();\n\n// Visit the request and each of its child nodes to print them\nawait requestPrintVisitor.Visit(\n    request,\n    new PrintVisitorState(stringWriter),\n    CancellationToken.None\n);\n\n// With all the nodes printed, get the text from the string writer\nvar text = stringWriter.ToString();\nConsole.WriteLine(text);\n// Example output: listSets()\n</code></pre> <p>Note</p> <p>There currently is no extension method to easily print FunQL queries. The print API is still evolving, and we hope  to improve this in the future.</p>"},{"location":"defining-a-schema/features/print/#advanced-configuration","title":"Advanced configuration","text":"<p>You can customize how printing works by passing an action to <code>AddPrintFeature()</code>. Common use cases include customizing how constants (JSON values) are serialized or swapping specific visitors for custom behavior.</p> <pre><code>public sealed class ApiSchema : Schema { protected override void OnInitializeSchema(ISchemaConfigBuilder schema) { \n        schema.AddPrintFeature(config =&gt; { \n            // Customize the print feature here            \n            // Example: Provide a custom constant printer (cache instance to \n            // avoid repeated allocations)\n            IConstantPrintVisitor&lt;IPrintVisitorState&gt;? visitor = null;\n            config.MutableConfig.ConstantPrintVisitorProvider = _ =&gt;\n                visitor ??= new MyCustomConstantPrintVisitor();\n        });\n    }\n}\n</code></pre> <p>Use this approach when you need to adjust or extend the behavior of the printing services.</p> <p>Tip</p> <p>Using Newtonsoft.Json in your application? No problem! Simply replace the default JSON printer with your own  Newtonsoft.Json printer.</p> <p>Learn how to integrate FunQL with Newtonsoft.Json \u2192.</p>"},{"location":"defining-a-schema/features/print/#whats-next","title":"What's next","text":"<p>With the features now all explained, check out the following pages:</p> <ul> <li>Learn more about requests \u2192</li> </ul>"},{"location":"defining-a-schema/features/validate/","title":"Validate","text":"<p>The validate feature ensures that FunQL requests comply with your schema's rules. It catches invalid queries early,  preventing them from being executed.</p> <p>This page explains how to enable validation, how to validate requests, and how to customize validation.</p>"},{"location":"defining-a-schema/features/validate/#adding-the-feature","title":"Adding the feature","text":"<p>The <code>AddValidateFeature()</code> method registers all services required for validating FunQL requests. Use this to set up the validate feature in your schema:</p> <pre><code>public sealed class ApiSchema : Schema\n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    {\n        schema.AddValidateFeature();\n    }\n}\n</code></pre> <p>This sets up the validate feature with default configurations and the core validation rules. See Advanced configuration on how to customize the feature.</p>"},{"location":"defining-a-schema/features/validate/#validating-requests","title":"Validating requests","text":"<p>Once the validate feature is added, you can validate a FunQL <code>Request</code> using:</p> <ul> <li><code>schema.ValidateRequest(Request request)</code>: Traverses the AST and runs the configured validation rules, throwing    <code>ValidationException</code> on validation errors.</li> </ul> <pre><code>var schema = new ApiSchema();\nvar request = schema.ParseRequest(\"listSets()\");\n\ntry\n{\n    schema.ValidateRequest(request);\n    // Valid request, continue to execution\n}\ncatch (ValidationException e)\n{\n    // Handle validation errors\n    // ValidationException.Errors contains the collected validation \n    // errors (message, location, etc.)\n    Console.WriteLine(\"Validation failed:\");\n    foreach (var error in e.Errors)\n    {\n        Console.WriteLine($\"- {error.Message}\");\n    }\n}\n</code></pre> <p>Tip</p> <p>Use the execute feature to simplify query processing. It automates essential steps like parsing,  validation, LINQ translation, and data fetching, allowing you to handle complex FunQL queries with just a single  method call.</p>"},{"location":"defining-a-schema/features/validate/#advanced-configuration","title":"Advanced configuration","text":"<p>The <code>AddValidateFeature()</code> method has three optional arguments:</p> <ul> <li><code>action</code>: An action to customize the feature.</li> <li><code>addVisitFeature</code>: Whether to add the visit feature. Default <code>true</code>. This is required by the default    <code>IValidator</code> implementation, so only disable if you are implementing your own validator.</li> <li><code>withCoreRules</code>: Whether to add the core validation rules. Default <code>true</code>.</li> </ul> <p>For example, disable the core validation rules and add your own:</p> <pre><code>public sealed class ApiSchema : Schema\n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema)\n    {\n        schema.AddValidateFeature(config =&gt;\n        {\n            // Customize the feature here\n            config.WithValidationRule(new MyCustomValidationRule());\n        }, withCoreRules: false);\n    }\n}\n</code></pre> <p>Use this to tailor the feature to your needs.</p>"},{"location":"defining-a-schema/features/validate/#custom-validation-rules","title":"Custom validation rules","text":"<p>You can extend the validation logic by adding your own rules. To get started:</p> <ul> <li>Inherit from <code>AbstractValidationRule&lt;T&gt;</code> for simple validators.</li> <li>Use <code>CompositeValidationRule</code> to group multiple rules.</li> <li>Implement <code>IValidationRule</code> for full control.</li> </ul> <p>The following example shows how to validate that <code>Skip</code> nodes have an integer constant:</p> <pre><code>public sealed class SkipHasIntConstant : AbstractValidationRule&lt;Skip&gt;\n{\n    public override Task ValidateOnEnter(Skip node, IValidatorState state, CancellationToken cancellationToken)\n    {\n        if (node.Constant.Value is int)\n            return Task.CompletedTask;\n\n        // Not an int, so error\n        state.AddError(new ValidationError($\"'{Skip.FunctionName}' value must be an integer.\", node.Constant));\n\n        // Can't validate invalid value, so stop validation\n        return Task.FromException(new ValidationException(state.Errors));\n    }\n}\n</code></pre> <p>Register it by calling <code>config.WithValidationRule(new SkipHasIntConstant())</code> inside the configuration action.</p> <p>Complex rules:</p> <p>For more complex scenarios (e.g., rules that depend on parent nodes), combine rules via <code>CompositeValidationRule</code> and  use a shared context to communicate between them. </p> <p>As an example, the following rule validates that there are no <code>FieldFunction</code> nodes used when inside a <code>Sort</code> node:</p> <pre><code>public sealed class SortHasNoFieldFunctions() : CompositeValidationRule(\n    new SortValidationRule(),\n    new FieldFunctionValidationRule()\n) {\n    // Context shared by rules\n    private sealed class Context : IValidateContext;\n\n    // Sort rule enters the Context for nested rules to use\n    private sealed class SortValidationRule : AbstractValidationRule&lt;Sort&gt;\n    {\n        public override Task ValidateOnEnter(Sort node, IValidatorState state, CancellationToken cancellationToken)\n        {\n            state.EnterContext(new Context());\n            return Task.CompletedTask;\n        }\n\n        public override Task ValidateOnExit(Sort node, IValidatorState state, CancellationToken cancellationToken)\n        {\n            // Make sure to exit context when done\n            state.ExitContext();\n            return Task.CompletedTask;\n        }\n    }\n\n    // FieldFunction rule adds error when Context is found\n    private sealed class FieldFunctionValidationRule : AbstractValidationRule&lt;FieldFunction&gt;\n    {\n        public override Task ValidateOnEnter(FieldFunction node, IValidatorState state, CancellationToken cancellationToken)\n        {\n            var context = state.FindContext&lt;Context&gt;();\n            // If context is found, it means we're inside a Sort node, so \n            // add the error\n            if (context != null) \n            {\n                state.AddError(new ValidationError(\n                    $\"Field functions are not supported when sorting.\",\n                    node\n                ));\n            }\n\n            return Task.CompletedTask;\n        }\n    }\n}\n</code></pre>"},{"location":"defining-a-schema/features/validate/#whats-next","title":"What's next","text":"<p>With the <code>Request</code> fully validated, it's time to fetch the data:</p> <ul> <li>Learn more about the execute feature \u2192</li> </ul>"},{"location":"defining-a-schema/features/visit/","title":"Visit","text":"<p>The visit feature provides the infrastructure to traverse and inspect the FunQL Abstract Syntax Tree (AST). It powers other features like validation and can also be extended for custom scenarios such as query analysis, rewriting, or  auditing.</p> <p>This page explains how to enable the visit feature, what it's used for, and how to customize it.</p>"},{"location":"defining-a-schema/features/visit/#adding-the-feature","title":"Adding the feature","text":"<p>Use <code>AddVisitFeature()</code> to register the services required to traverse FunQL ASTs:</p> <pre><code>public sealed class ApiSchema : Schema \n{\n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {\n        schema.AddVisitFeature();\n    }\n}\n</code></pre> <p>This sets up the visit feature with default configurations. Other features (like validate) will leverage it to walk the AST.</p>"},{"location":"defining-a-schema/features/visit/#visiting-requests","title":"Visiting requests","text":"<p>While the visit feature is primarily used by other features, you can also use it directly to traverse the AST. For  example, to visit all nodes of a request:</p> <pre><code>var schema = new ApiSchema(); \nvar request = schema.ParseRequest(\"listSets()\");\n\n// Get the request visitor from the Schema\nvar requestVisitor = schema.SchemaConfig.FindVisitConfigExtension()\n    .RequestVisitorProvider(schema.SchemaConfig);\n\n// Visit the request and each of its child nodes\nawait requestVisitor.Visit(\n    request,\n    new VisitorState(\n        // Callback called upon entering a node\n        onEnter: (node, state, token) =&gt; Task.CompletedTask,\n        // Callback called upon exiting a node\n        onExit: (node, state, token) =&gt; Task.CompletedTask\n    ),\n    CancellationToken.None\n);\n</code></pre> <p>The <code>VisitorState</code> lets you perform custom logic when visiting nodes via the <code>onEnter</code> and <code>onExit</code> callbacks. Each  visitor calls these for every node it visits. The callbacks are fully async so you can perform non-blocking work during  traversal, like auditing or permission checks.</p>"},{"location":"defining-a-schema/features/visit/#advanced-configuration","title":"Advanced configuration","text":"<p>You can customize the visit feature by passing an action to <code>AddVisitFeature()</code>:</p> <pre><code>public sealed class ApiSchema : Schema { \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) { \n        schema.AddVisitFeature(config =&gt; { \n            // Customize the feature here\n            // Example: Provide a custom visitor for field functions (cache \n            // instance to avoid repeated allocations)\n            MyCustomFieldFunctionVisitor? visitor = null;\n            config.MutableConfig.FieldFunctionVisitorProvider = _ =&gt; \n                visitor ??= new MyCustomFieldFunctionVisitor();\n        }); \n    }\n}\n</code></pre> <p>Note</p> <p>If you introduce custom node types, ensure corresponding visitors properly handle them. Otherwise, traversal may  result in exceptions. For example, if you introduce a new <code>FieldFunction</code> type, ensure the <code>FieldFunctionVisitor</code>  properly handles the new type.</p>"},{"location":"defining-a-schema/features/visit/#whats-next","title":"What's next","text":"<p>See how the visit feature is used in other parts:</p> <ul> <li>Learn more about the print feature \u2192</li> </ul>"},{"location":"defining-a-schema/fields/","title":"Fields","text":"<p>Work in Progress</p> <p>We are actively working on the documentation for FunQL .NET. Please check back later or visit our repository to track progress or contribute.</p>"},{"location":"defining-a-schema/parameters/","title":"Parameters","text":"<p>Parameters add query capabilities to a request (e.g., filtering, sorting, pagination). When configuring a request, you  explicitly enable the parameters it should support.</p> <p>This page gives an overview of all parameters.</p>"},{"location":"defining-a-schema/parameters/#filter","title":"Filter","text":"<p>The <code>filter</code> parameter specifies one or more predicates to filter the data with. Predicates can be combined using  <code>and()</code> and <code>or()</code> to create more advanced filters. </p> <p>Examples:</p> <ul> <li><code>filter(gte(price, 500))</code></li> <li><code>filter(and(gte(price, 500), has(upper(name), \"STAR\")))</code></li> </ul> <p>Enabling the parameter:</p> <pre><code>public sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {        \n        schema.Request(\"listSets\")\n            .SupportsFilter();\n    }\n}\n</code></pre> <p>Learn more about the filter parameter \u2192</p>"},{"location":"defining-a-schema/parameters/#sort","title":"Sort","text":"<p>The <code>sort</code> parameter defines how to sort the data. Expressions can be combined using a comma (<code>,</code>).</p> <p>Examples:</p> <ul> <li><code>sort(desc(price))</code></li> <li><code>sort(desc(price), asc(lower(name)))</code></li> </ul> <p>Enabling the parameter:</p> <pre><code>public sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {        \n        schema.Request(\"listSets\")\n            .SupportsSort();\n    }\n}\n</code></pre> <p>Learn more about the sort parameter \u2192</p>"},{"location":"defining-a-schema/parameters/#skip","title":"Skip","text":"<p>The <code>skip</code> parameter specifies how many items to skip from the result set before returning data. It is commonly used for  pagination in combination with the <code>limit</code> parameter.</p> <p>Example:</p> <ul> <li><code>skip(20)</code></li> </ul> <p>Enabling the parameter:</p> <pre><code>public sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {        \n        schema.Request(\"listSets\")\n            .SupportsSkip();\n    }\n}\n</code></pre> <p>Learn more about the skip parameter \u2192</p>"},{"location":"defining-a-schema/parameters/#limit","title":"Limit","text":"<p>The <code>limit</code> parameter restricts the maximum number of items returned in a single response. It is commonly used for  pagination in combination with the <code>skip</code> parameter.</p> <p>Example:</p> <ul> <li><code>limit(10)</code></li> </ul> <p>Enabling the parameter:</p> <pre><code>public sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {        \n        schema.Request(\"listSets\")\n            .SupportsLimit();\n    }\n}\n</code></pre> <p>Learn more about the limit parameter \u2192</p>"},{"location":"defining-a-schema/parameters/#count","title":"Count","text":"<p>The <code>count</code> parameter requests the total number of items matching the current query. It is commonly used in combination  with pagination to display the total number of available results.</p> <p>Example:</p> <ul> <li><code>count(true)</code></li> </ul> <p>Enabling the parameter:</p> <pre><code>public sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {        \n        schema.Request(\"listSets\")\n            .SupportsCount();\n    }\n}\n</code></pre> <p>Learn more about the count parameter \u2192</p>"},{"location":"defining-a-schema/parameters/#input","title":"Input","text":"<p>The <code>input</code> parameter specifies the input for a certain request.</p> <p>Example:</p> <ul> <li><code>input({\"name\": \"LEGO Star Wars R2-D2\"})</code></li> </ul> <p>Enabling the parameter:</p> <pre><code>public sealed record SetInput(string Name);\n\npublic sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {        \n        schema.Request(\"addSet\")\n            .SupportsInput&lt;SetInput&gt;();\n    }\n}\n</code></pre> <p>Learn more about the input parameter \u2192</p>"},{"location":"defining-a-schema/parameters/count/","title":"Count","text":"<p>The <code>count</code> parameter requests the total number of items matching the current query (after filters, before paging). It's commonly used alongside pagination to display the total available results.</p>"},{"location":"defining-a-schema/parameters/count/#syntax","title":"Syntax","text":"<ul> <li><code>count(value: Boolean)</code></li> </ul> <p>Examples:</p> <ul> <li><code>count(true)</code></li> <li><code>count(false)</code></li> </ul>"},{"location":"defining-a-schema/parameters/count/#c-representation","title":"C# representation","text":"<p>The <code>count</code> function is represented by the <code>Count</code> node in C#. For example:</p> <pre><code>count(true)\n</code></pre> <p>corresponds to:</p> <pre><code>new Count(new Constant(true));\n</code></pre> <p>The <code>Count</code> node has a single child, a <code>Constant</code> node containing a boolean that enables or disables counting.</p>"},{"location":"defining-a-schema/parameters/count/#configuration","title":"Configuration","text":"<p>Enable the <code>count</code> parameter for a request by calling the <code>SupportsCount()</code> method. Optionally, pass an action to  configure the parameter further, for example, to set the default value:</p> <pre><code>public sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {        \n        schema.Request(\"listSets\")\n            .SupportsCount(config =&gt; \n            {\n                // Return total count by default\n                config.HasDefaultValue(new Count(new Constant(true))); \n            });\n    }\n}\n</code></pre> <p>Note</p> <p>If <code>count</code> isn't provided and no default is set, it's treated as <code>false</code>.</p>"},{"location":"defining-a-schema/parameters/count/#execution","title":"Execution","text":"<p>When executing a query with the <code>count</code> parameter, the <code>Count</code> node is first validated against the following rules:</p> <ul> <li>Value must be a boolean.</li> </ul> <p>If valid, the <code>Count</code> node can be applied to the result set:</p> <pre><code>public sealed record Set(string Name, double Price, DateTime LaunchTime);\n\nvar sets = new List&lt;Set&gt;\n{\n    new(\"LEGO Star Wars Millennium Falcon\", 849.99, new DateTime(2017, 10, 01)),\n    new(\"LEGO Star Wars The Razor Crest\", 599.99, new DateTime(2022, 10, 03)),\n    new(\"LEGO DC Batman Batmobile Tumbler\", 269.99, new DateTime(2021, 11, 01)),\n    new(\"LEGO Harry Potter Hogwarts Castle\", 469.99, new DateTime(2018, 09, 01)),\n};\n\n// 'count(true)' node (e.g., from parsing)\nvar count = new Count(new Constant(true));\n\n// Only count if 'count' is true\nif (count.Value() == true) \n{\n    var totalCount = sets.Count();\n\n    Console.WriteLine(totalCount);\n    // Output:\n    // 4\n}\n</code></pre> <p>Note</p> <p>When combined with parameters such as <code>filter</code>, the <code>count</code> reflects the number of results after filtering. Make  sure to count the total number of results before applying <code>skip</code> and <code>limit</code> parameters, otherwise the count  will not reflect the total number of results.</p> <p>If you use the execute feature, this is handled for you automatically.</p>"},{"location":"defining-a-schema/parameters/count/#pagination","title":"Pagination","text":"<p>When using pagination (with <code>skip</code> and <code>limit</code>), use <code>count(true)</code> to request the total matches:</p> RESTQL <pre><code>GET http://localhost:5000/sets\n  ?skip=10\n  &amp;limit=10\n  &amp;count=true\n</code></pre> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\nTotal-Count: 70\n\n[\n  ..\n]\n</code></pre> <p>Note</p> <p>In REST responses, the total count is included in the <code>Total-Count</code> header.</p> <pre><code>listSets(\n  skip(10),\n  limit(10),\n  count(true)\n)\n</code></pre> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"data\": [\n    ..\n  ],\n  \"metadata\": {\n    \"totalCount\": 70\n  }\n}\n</code></pre>"},{"location":"defining-a-schema/parameters/filter/","title":"Filter","text":"<p>The <code>filter</code> parameter specifies one or more predicates to filter the data with. Predicates can be combined using  logical operators like <code>and()</code> and <code>or()</code> to create more advanced filters.</p>"},{"location":"defining-a-schema/parameters/filter/#syntax","title":"Syntax","text":"<ul> <li><code>filter(predicate: BooleanExpression)</code></li> <li>Comparison <code>BooleanExpression</code>:<ul> <li><code>eq(field: FieldArgument, value: Constant)</code></li> <li><code>ne(field: FieldArgument, value: Constant)</code></li> <li><code>gt(field: FieldArgument, value: Constant)</code></li> <li><code>gte(field: FieldArgument, value: Constant)</code></li> <li><code>lt(field: FieldArgument, value: Constant)</code></li> <li><code>lte(field: FieldArgument, value: Constant)</code></li> </ul> </li> <li>Logical <code>BooleanExpression</code>:<ul> <li><code>and(left: BooleanExpression, right: BooleanExpression)</code></li> <li><code>or(left: BooleanExpression, right: BooleanExpression)</code></li> <li><code>not(predicate: BooleanExpression)</code></li> </ul> </li> <li>String <code>BooleanExpression</code>:<ul> <li><code>has(field: FieldArgument, value: Constant)</code></li> <li><code>stw(field: FieldArgument, value: Constant)</code></li> <li><code>enw(field: FieldArgument, value: Constant)</code></li> <li><code>reg(field: FieldArgument, value: Constant)</code></li> </ul> </li> <li>List <code>BooleanExpression</code>:<ul> <li><code>any(field: FieldPath, predicate: BooleanExpression)</code></li> <li><code>all(field: FieldPath, predicate: BooleanExpression)</code></li> </ul> </li> </ul> <p>Examples:</p> <ul> <li><code>filter(gte(price, 500))</code></li> <li><code>filter(and(gte(price, 500), has(upper(name), \"STAR\")))</code></li> </ul>"},{"location":"defining-a-schema/parameters/filter/#c-representation","title":"C# representation","text":"<p>The <code>filter</code> parameter is represented by the <code>Filter</code> node in C#. For example:</p> <pre><code>filter(gte(price, 500))\n</code></pre> <p>corresponds to:</p> <pre><code>new Filter(\n    new GreaterThanOrEqual(\n        new FieldPath([new NamedField(\"price\")]), \n        new Constant(500)\n    )\n);\n</code></pre> <p>The <code>Filter</code> node contains a single predicate expression defining how to filter the results.</p>"},{"location":"defining-a-schema/parameters/filter/#configuration","title":"Configuration","text":"<p>Enable the <code>filter</code> parameter for a request by calling the <code>SupportsFilter()</code> method. Optionally, pass an action to configure the parameter further, for example, to set the default value:</p> <pre><code>public sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {        \n        schema.Request(\"listSets\")\n            .SupportsFilter(config =&gt; \n            {\n                // Only include sets worth 10 or more by default\n                config.HasDefaultValue(new Filter(\n                    new GreaterThanOrEqual(\n                        new FieldPath([new NamedField(\"price\")]), \n                        new Constant(10)\n                    )\n                ));\n            });\n    }\n}\n</code></pre> <p>Then configure which fields support filtering:</p> <pre><code>public sealed record Set(string Name, double Price, DateTime LaunchTime);\n\npublic sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {        \n        schema.Request(\"listSets\")\n            .SupportsSort(config =&gt; { .. })\n            .ReturnsListOfObjects&lt;Set&gt;(set =&gt;\n            {\n                set.SimpleField(it =&gt; it.Price)\n                    .HasName(\"price\")\n                    // Enable filtering by price\n                    .SupportsFilter(config =&gt; \n                    {\n                        // Enable functions like 'eq', 'gt', 'lte', 'floor'\n                        config.SupportsDoubleFilterFunctions();\n                    });\n            });\n    }\n}\n</code></pre> <p>Note</p> <p>Filtering must be explicitly enabled per field. If <code>filter</code> is not provided when executing a request and no default  is set, no filtering is applied.</p>"},{"location":"defining-a-schema/parameters/filter/#execution","title":"Execution","text":"<p>When executing a query with the <code>filter</code> parameter, the <code>Filter</code> node is first validated against the following rules:</p> <ul> <li>Filter must be supported for the request.</li> <li>Filter must be supported for the target fields.</li> <li>Filter <code>Constant</code> values must be valid for the target fields.</li> </ul> <p>If valid, the <code>Filter</code> node can be applied to the result set:</p> <pre><code>public sealed record Set(string Name, double Price, DateTime LaunchTime);\n\nvar sets = new List&lt;Set&gt;\n{\n    new(\"LEGO Star Wars Millennium Falcon\", 849.99, new DateTime(2017, 10, 01)),\n    new(\"LEGO Star Wars The Razor Crest\", 599.99, new DateTime(2022, 10, 03)),\n    new(\"LEGO DC Batman Batmobile Tumbler\", 269.99, new DateTime(2021, 11, 01)),\n    new(\"LEGO Harry Potter Hogwarts Castle\", 469.99, new DateTime(2018, 09, 01)),\n};\n\n// 'filter(and(gte(price, 500), has(upper, \"STAR\")))' node (e.g., from parsing)\nvar filter = new Filter(\n    new And(\n        new GreaterThanOrEqual(\n            new FieldPath([new NamedField(\"price\")]), \n            new Constant(500)\n        ),\n        new Has(\n            new Upper(new FieldPath([new NamedField(\"name\")])),\n            new Constant(\"STAR\")\n        )\n    )\n);\n\n// Apply filter to data set\nvar results = sets.AsQueryable()\n    // Equivalent LINQ:\n    // sets.Where(it =&gt; it.Price &gt;= 500)\n    //     .Where(it =&gt; it.Name.ToUpper().Contains(\"STAR\"))\n    .ApplyFilter(schema.SchemaConfig, \"listSets\", filter)\n    .ToList();\n\n// Print the result\nConsole.WriteLine(string.Join(\"\\n\", results));\n// Output:\n// Set { Name = LEGO Star Wars Millennium Falcon, Price = 849.99, LaunchTime = 1-10-2017 00:00:00 }\n// Set { Name = LEGO Star Wars The Razor Crest, Price = 599.99, LaunchTime = 3-10-2022 00:00:00 }\n</code></pre>"},{"location":"defining-a-schema/parameters/input/","title":"Input","text":"<p>The <code>input</code> parameter specifies structured input data for a request. It's typically used for create and update  operations, but can be used by any request that requires extra data.</p>"},{"location":"defining-a-schema/parameters/input/#syntax","title":"Syntax","text":"<ul> <li><code>input(value: Any)</code></li> </ul> <p>Examples:</p> <ul> <li><code>input(\"533d3fe3-bccc-405a-9904-4f516e892856\")</code></li> <li><code>input({\"name\": \"LEGO Star Wars Millennium Falcon\"})</code></li> </ul>"},{"location":"defining-a-schema/parameters/input/#c-representation","title":"C# representation","text":"<p>The <code>input</code> parameter is represented by the <code>Input</code> node in C#. For example:</p> <pre><code>input({\"name\": \"LEGO Star Wars Millennium Falcon\"})\n</code></pre> <p>corresponds to:</p> <pre><code>public sealed record SetInput(string Name);\n\nnew Input(new Constant(new SetInput(\"LEGO Star Wars Millennium Falcon\"));\n</code></pre> <p>The <code>Input</code> node has a single child, a <code>Constant</code> node containing the input value.</p>"},{"location":"defining-a-schema/parameters/input/#configuration","title":"Configuration","text":"<p>Enable the <code>input</code> parameter for a request by calling the <code>SupportsInput&lt;TInput&gt;()</code> method, specifying the input type:</p> <pre><code>public sealed record SetInput(string Name);\n\npublic sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {        \n        schema.Request(\"addSet\")\n            .SupportsInput&lt;SetInput&gt;(config =&gt; \n            {\n                // Configure the parameter\n            });\n    }\n}\n</code></pre> <p>Note</p> <p>The configured .NET type is used to parse and validate the <code>input</code> value.</p>"},{"location":"defining-a-schema/parameters/input/#execution","title":"Execution","text":"<p>Use the <code>input</code> parameter to supply data to your request handler, for example, to add an item:</p> <pre><code>public sealed record Set(string Name, double Price, DateTime LaunchTime);\n\nvar sets = new List&lt;Set&gt;\n{\n    new(\"LEGO Star Wars Millennium Falcon\", 849.99, new DateTime(2017, 10, 01)),\n};\n\n// Input node (e.g., from parsing)\n// input({\n//   \"name\": \"LEGO Star Wars The Razor Crest\", \n//   \"price\": 599.99, \n//   \"launchTime\": \"2022-10-03T00:00:00\"\n// })\nvar input = new Input(new Constant(\n    new SetInput(\n        \"LEGO Star Wars The Razor Crest\", \n        599.99,\n        new DateTime(2022, 10, 03)\n    )\n));\n\n// Add the item to the data set\nsets.Add(input.Constant.Value);\n\n// Print the result\nConsole.WriteLine(string.Join(\"\\n\", sets));\n// Output:\n// Set { Name = LEGO Star Wars Millennium Falcon, Price = 849.99, LaunchTime = 1-10-2017 00:00:00 }\n// Set { Name = LEGO Star Wars The Razor Crest, Price = 599.99, LaunchTime = 3-10-2022 00:00:00 }\n</code></pre>"},{"location":"defining-a-schema/parameters/limit/","title":"Limit","text":"<p>The <code>limit</code> parameter restricts the maximum number of items returned in a single response. It is commonly used for pagination in combination with the <code>skip</code> parameter.</p>"},{"location":"defining-a-schema/parameters/limit/#syntax","title":"Syntax","text":"<ul> <li><code>limit(value: Integer)</code></li> </ul> <p>Examples:</p> <ul> <li><code>limit(10)</code></li> <li><code>limit(100)</code></li> </ul>"},{"location":"defining-a-schema/parameters/limit/#c-representation","title":"C# representation","text":"<p>The <code>limit</code> parameter is represented by the <code>Limit</code> node in C#. For example:</p> <pre><code>limit(10)\n</code></pre> <p>corresponds to:</p> <pre><code>new Limit(new Constant(10));\n</code></pre> <p>The <code>Limit</code> node has a single child, a <code>Constant</code> node containing the maximum number of items to return.</p>"},{"location":"defining-a-schema/parameters/limit/#configuration","title":"Configuration","text":"<p>Enable the <code>limit</code> parameter for a request by calling the <code>SupportsLimit()</code> method. Optionally, pass an action to configure the parameter further, for example, to set the default and maximum values:</p> <pre><code>public sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {        \n        schema.Request(\"listSets\")\n            .SupportsLimit(config =&gt; \n            {                \n                // Return at most 20 items by default\n                config.HasDefaultValue(new Limit(new Constant(20)))\n                    // Reject values greater than 100\n                    .HasMaxLimit(100);\n            });\n    }\n}\n</code></pre> <p>Note</p> <p>If <code>limit</code> is not provided when executing a request and no default is set, the effective behavior is to return all  remaining items (depending on the data source used, like EF Core).</p>"},{"location":"defining-a-schema/parameters/limit/#execution","title":"Execution","text":"<p>When executing a query with the <code>limit</code> parameter, the <code>Limit</code> node is first validated against the following rules:</p> <ul> <li>Value must be an integer.</li> <li>Value must be greater than or equal to 0.</li> <li>Value must be less than or equal to the maximum limit value.</li> </ul> <p>If valid, the <code>Limit</code> node can be applied to the result set:</p> <pre><code>public sealed record Set(string Name, double Price, DateTime LaunchTime);\n\nvar sets = new List&lt;Set&gt;\n{\n    new(\"LEGO Star Wars Millennium Falcon\", 849.99, new DateTime(2017, 10, 01)),\n    new(\"LEGO Star Wars The Razor Crest\", 599.99, new DateTime(2022, 10, 03)),\n    new(\"LEGO DC Batman Batmobile Tumbler\", 269.99, new DateTime(2021, 11, 01)),\n    new(\"LEGO Harry Potter Hogwarts Castle\", 469.99, new DateTime(2018, 09, 01)),\n};\n\n// 'limit(1)' node (e.g., from parsing)\nvar limit = new Limit(new Constant(1));\n\n// Apply limit to data set\nvar results = sets.AsQueryable()\n    // Equivalent LINQ:\n    // .Take(1)\n    .ApplyLimit(limit)\n    .ToList();\n\n// Print the result\nConsole.WriteLine(string.Join(\"\\n\", results));\n// Output:\n// Set { Name = LEGO Star Wars Millennium Falcon, Price = 849.99, LaunchTime = 1-10-2017 00:00:00 }\n</code></pre>"},{"location":"defining-a-schema/parameters/limit/#pagination","title":"Pagination","text":"<p>Combine the <code>skip</code> and <code>limit</code> parameters to implement page/offset navigation. For example, to get the second page of results with 10 items per page, you can use the following query:</p> RESTQL <pre><code>GET http://localhost:5000/sets\n  ?skip=10\n  &amp;limit=10\n</code></pre> <pre><code>listSets(\n  skip(10),\n  limit(10)\n)\n</code></pre> <p>Tip</p> <p>Use a stable sort with paging to avoid item drift between pages (e.g., sort by <code>createTime</code>).</p>"},{"location":"defining-a-schema/parameters/skip/","title":"Skip","text":"<p>The <code>skip</code> parameter specifies how many items to skip from the result set before returning data. It is commonly used for pagination in combination with the <code>limit</code> parameter.</p>"},{"location":"defining-a-schema/parameters/skip/#syntax","title":"Syntax","text":"<ul> <li><code>skip(value: Integer)</code></li> </ul> <p>Examples:</p> <ul> <li><code>skip(10)</code></li> <li><code>skip(20)</code></li> </ul>"},{"location":"defining-a-schema/parameters/skip/#c-representation","title":"C# representation","text":"<p>The <code>skip</code> parameter is represented by the <code>Skip</code> node in C#. For example:</p> <pre><code>skip(20)\n</code></pre> <p>corresponds to:</p> <pre><code>new Skip(new Constant(20));\n</code></pre> <p>The <code>Skip</code> node has a single child, a <code>Constant</code> node containing the number of items to skip.</p>"},{"location":"defining-a-schema/parameters/skip/#configuration","title":"Configuration","text":"<p>Enable the <code>skip</code> parameter for a request by calling the <code>SupportsSkip()</code> method. Optionally, pass an action to configure the parameter further, for example, to set the default value:</p> <pre><code>public sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {        \n        schema.Request(\"listSets\")\n            .SupportsSkip(config =&gt; \n            {\n                // Skip first 20 items by default\n                config.HasDefaultValue(new Skip(new Constant(20)));\n            });\n    }\n}\n</code></pre> <p>Note</p> <p>If <code>skip</code> is not provided when executing a request and no default is set, the effective value is <code>0</code>.</p>"},{"location":"defining-a-schema/parameters/skip/#execution","title":"Execution","text":"<p>When executing a query with the <code>skip</code> parameter, the <code>Skip</code> node is first validated against the following rules:</p> <ul> <li>Value must be an integer.</li> <li>Value must be greater than or equal to 0.</li> </ul> <p>If valid, the <code>Skip</code> node can be applied to the result set:</p> <pre><code>public sealed record Set(string Name, double Price, DateTime LaunchTime);\n\nvar sets = new List&lt;Set&gt;\n{\n    new(\"LEGO Star Wars Millennium Falcon\", 849.99, new DateTime(2017, 10, 01)),\n    new(\"LEGO Star Wars The Razor Crest\", 599.99, new DateTime(2022, 10, 03)),\n    new(\"LEGO DC Batman Batmobile Tumbler\", 269.99, new DateTime(2021, 11, 01)),\n    new(\"LEGO Harry Potter Hogwarts Castle\", 469.99, new DateTime(2018, 09, 01)),\n};\n\n// 'skip(3)' node (e.g., from parsing)\nvar skip = new Skip(new Constant(3));\n\n// Apply skip to data set\nvar results = sets.AsQueryable()\n    // Equivalent LINQ:\n    // .Skip(3)\n    .ApplySkip(skip)\n    .ToList();\n\n// Print the result\nConsole.WriteLine(string.Join(\"\\n\", results));\n// Output:\n// Set { Name = LEGO Harry Potter Hogwarts Castle, Price = 469.99, LaunchTime = 1-9-2018 00:00:00 }\n</code></pre>"},{"location":"defining-a-schema/parameters/skip/#pagination","title":"Pagination","text":"<p>Combine the <code>skip</code> and <code>limit</code> parameters to implement page/offset navigation. For example, to get the second page of results with 10 items per page, you can use the following query:</p> RESTQL <pre><code>GET http://localhost:5000/sets\n  ?skip=10\n  &amp;limit=10\n</code></pre> <pre><code>listSets(\n  skip(10),\n  limit(10)\n)\n</code></pre> <p>Tip</p> <p>Use a stable sort with paging to avoid item drift between pages (e.g., sort by <code>createTime</code>).</p>"},{"location":"defining-a-schema/parameters/sort/","title":"Sort","text":"<p>The <code>sort</code> parameter defines the ordering of results. Multiple sort expressions can be combined by separating them with a comma (<code>,</code>).</p>"},{"location":"defining-a-schema/parameters/sort/#syntax","title":"Syntax","text":"<ul> <li><code>sort(expressions: SortExpression[])</code></li> <li><code>SortExpression</code>:<ul> <li><code>asc(field: FieldArgument)</code></li> <li><code>desc(field: FieldArgument)</code></li> </ul> </li> </ul> <p>Examples:</p> <ul> <li><code>sort(asc(name))</code></li> <li><code>sort(desc(price), asc(lower(name)))</code></li> </ul>"},{"location":"defining-a-schema/parameters/sort/#c-representation","title":"C# representation","text":"<p>The <code>sort</code> parameter is represented by the <code>Sort</code> node in C#. For example:</p> <pre><code>sort(desc(price))\n</code></pre> <p>corresponds to:</p> <pre><code>new Sort([\n    new Descending(new FieldPath([new NamedField(\"price\")]))\n]);\n</code></pre> <p>The <code>Sort</code> node has one or more <code>SortExpression</code> children. Each <code>SortExpression</code> is either an <code>Ascending</code> or  <code>Descending</code> node, defining the field to sort by.</p>"},{"location":"defining-a-schema/parameters/sort/#configuration","title":"Configuration","text":"<p>Enable the <code>sort</code> parameter for a request by calling the <code>SupportsSort()</code> method. Optionally, pass an action to  configure the parameter further, for example, to set the default value:</p> <pre><code>public sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {        \n        schema.Request(\"listSets\")\n            .SupportsSort(config =&gt; \n            {\n                // Sort by name by default\n                config.HasDefaultValue(new Sort([\n                    new Ascending(new FieldPath([new NamedField(\"name\")]))\n                ]));\n            });\n    }\n}\n</code></pre> <p>Then configure which fields support sorting:</p> <pre><code>public sealed record Set(string Name, double Price, DateTime LaunchTime);\n\npublic sealed class ApiSchema : Schema\n{ \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) \n    {        \n        schema.Request(\"listSets\")\n            .SupportsSort(config =&gt; { .. })\n            .ReturnsListOfObjects&lt;Set&gt;(set =&gt;\n            {\n                set.SimpleField(it =&gt; it.Price)\n                    .HasName(\"price\")\n                    // Enable sorting by price\n                    .SupportsSort(config =&gt; \n                    {\n                        // Enable field functions like 'floor()' and 'ceiling()' \n                        config.SupportsDoubleFieldFunctions();\n                    });\n            });\n    }\n}\n</code></pre> <p>Note</p> <p>Sorting must be explicitly enabled per field. If <code>sort</code> is not provided when executing a request and no default  is set, the effective ordering depends on the underlying data source. Prefer using a stable default sort (e.g., by  <code>id</code> or <code>createTime</code>).</p>"},{"location":"defining-a-schema/parameters/sort/#execution","title":"Execution","text":"<p>When executing a query with the <code>sort</code> parameter, the <code>Sort</code> node is first validated against the following rules:</p> <ul> <li>Sort must be supported for request.</li> <li>Sort must be supported for the target field.</li> </ul> <p>If valid, the <code>Sort</code> node can be applied to the result set:</p> <pre><code>public sealed record Set(string Name, double Price, DateTime LaunchTime);\n\nvar sets = new List&lt;Set&gt;\n{\n    new(\"LEGO Star Wars Millennium Falcon\", 849.99, new DateTime(2017, 10, 01)),\n    new(\"LEGO Star Wars The Razor Crest\", 599.99, new DateTime(2022, 10, 03)),\n    new(\"LEGO DC Batman Batmobile Tumbler\", 269.99, new DateTime(2021, 11, 01)),\n    new(\"LEGO Harry Potter Hogwarts Castle\", 469.99, new DateTime(2018, 09, 01)),\n};\n\n// 'sort(desc(price))' node (e.g., from parsing)\nvar sort = new Sort([\n    new Descending(new FieldPath([new NamedField(\"price\")])),\n    new Ascending(new FieldPath([new NamedField(\"name\")]))\n]);\n\n// Apply sort to data set\nvar results = sets.AsQueryable()\n    // Equivalent LINQ:\n    // sets.OrderByDescending(it =&gt; it.Price)\n    //     .ThenBy(it =&gt; it.Name)\n    .ApplySort(schema.SchemaConfig, \"listSets\", sort, alreadyOrdered: false)\n    .ToList();\n\n// Print the result\nConsole.WriteLine(string.Join(\"\\n\", results));\n// Output:\n// Set { Name = LEGO Star Wars Millennium Falcon, Price = 849.99, LaunchTime = 1-10-2017 00:00:00 }\n// Set { Name = LEGO Star Wars The Razor Crest, Price = 599.99, LaunchTime = 3-10-2022 00:00:00 }\n// Set { Name = LEGO Harry Potter Hogwarts Castle, Price = 469.99, LaunchTime = 1-9-2018 00:00:00 }\n// Set { Name = LEGO DC Batman Batmobile Tumbler, Price = 269.99, LaunchTime = 1-11-2021 00:00:00 }\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>FunQL .NET comes with practical examples that demonstrate common use cases and integration patterns to get you started  quickly.</p>"},{"location":"examples/#basic-example","title":"Basic Example","text":"<p>The Basic example is a minimal, self-contained console application that demonstrates how to:</p> <ul> <li>Configure a FunQL schema</li> <li>Filter and sort data using FunQL query parameters</li> </ul> <p>Learn more about the Basic example \u2192</p>"},{"location":"examples/#webapi-example","title":"WebApi Example","text":"<p>The WebApi example showcases how to integrate FunQL into a real-world ASP.NET Core Web API application. This example covers:</p> <ul> <li>Setting up FunQL in an ASP.NET Core project</li> <li>Integrating with Entity Framework Core (EF Core)</li> <li>Integrating with Noda Time</li> <li>Creating minimal APIs with FunQL support</li> </ul> <p>Learn more about the WebApi example \u2192</p>"},{"location":"examples/basic/","title":"Basic","text":"<p>Work in Progress</p> <p>We are actively working on the documentation for FunQL .NET. Please check back later or visit our repository to track progress or contribute.</p>"},{"location":"examples/webapi/","title":"WebApi","text":"<p>Work in Progress</p> <p>We are actively working on the documentation for FunQL .NET. Please check back later or visit our repository to track progress or contribute.</p>"},{"location":"executing-queries/","title":"Executing queries","text":"<p>Once the <code>Schema</code> is set up, it can be used to execute FunQL queries. All you need for this is an <code>IQueryable</code> data  source that FunQL uses to query the data. </p> <p>This section will explain more about how to query data and the underlying execution pipeline.</p>"},{"location":"executing-queries/#execution-pipeline","title":"Execution pipeline","text":"<p>Executing a FunQL request involves several steps, including parsing, validating, LINQ translation, and the actual query  execution. While you can use the <code>Schema</code> to handle these steps manually, the FunQL execution pipeline simplifies this  process by ensuring that all steps are performed in the correct order and in the right way, reducing complexity for developers.</p> <p>Learn more about the execution pipeline \u2192</p>"},{"location":"executing-queries/#example-request","title":"Example request","text":"<p>For this example, we will query an in-memory list of LEGO sets, which we configured in Defining a schema. FunQL provides two execution methods:</p> <ol> <li><code>ExecuteRequestForParameters()</code>: Designed for REST APIs where FunQL parameters like <code>filter</code> and <code>sort</code> are     passed as URL query parameters.</li> <li><code>ExecuteRequest()</code>: Designed for full FunQL queries, treating FunQL as a query language (QL). This approach     combines all parameters into a single query.</li> </ol> RESTQL <pre><code>// Define the data model\npublic sealed record Set(string Name, double Price, DateTime LaunchTime);\n\n// Prepare in-memory data\nvar sets = new List&lt;Set&gt;\n{\n    new(\"LEGO Star Wars Millennium Falcon\", 849.99, new DateTime(2017, 10, 01)),\n    new(\"LEGO Star Wars The Razor Crest\", 599.99, new DateTime(2022, 10, 03)),\n    new(\"LEGO DC Batman Batmobile Tumbler\", 269.99, new DateTime(2021, 11, 01)),\n    new(\"LEGO Harry Potter Hogwarts Castle\", 469.99, new DateTime(2018, 09, 01)),\n};\n\n// Define query parameters\nconst string filter = @\"and(\n  has(upper(name), \"\"STAR WARS\"\"),\n  gte(price, 500),\n  gt(year(launchTime), 2010)\n)\";\nconst string sort = \"desc(price)\";\n\n// Create the configured schema\nvar schema = new ApiSchema();\n\n// Execute the listSets() FunQL request for the 'filter' and 'sort' parameters\nvar result = await sets\n    .ExecuteRequestForParameters(\n        schema, \n        requestName: \"listSets\", \n        filter: filter, \n        sort: sort\n    );\n</code></pre> <p>The <code>ExecuteRequestForParameters()</code> method is ideal for REST APIs. It will process the <code>filter</code> and <code>sort</code>  parameters using the FunQL execution pipeline, which runs the following steps:</p> <ol> <li>Parse the <code>filter</code> and <code>sort</code> parameters using the <code>listSets</code> request configuration</li> <li>Validate the parameters based on the <code>listSets</code> request configuration</li> <li>Translate the parameters to LINQ expressions</li> <li>Apply the LINQ expressions to given <code>IQueryable&lt;Set&gt;</code></li> <li>Execute the query, fetching the filtered and sorted result</li> </ol> <pre><code>// Define the data model\npublic sealed record Set(string Name, double Price, DateTime LaunchTime);\n\n// Prepare in-memory data\nvar sets = new List&lt;Set&gt;\n{\n    new(\"LEGO Star Wars Millennium Falcon\", 849.99, new DateTime(2017, 10, 01)),\n    new(\"LEGO Star Wars The Razor Crest\", 599.99, new DateTime(2022, 10, 03)),\n    new(\"LEGO DC Batman Batmobile Tumbler\", 269.99, new DateTime(2021, 11, 01)),\n    new(\"LEGO Harry Potter Hogwarts Castle\", 469.99, new DateTime(2018, 09, 01)),\n};\n\n// Define FunQL request \nconst string request = @\"listSets(\n  filter(\n    and(\n      has(upper(name), \"\"STAR WARS\"\"),\n      gte(price, 500),\n      gt(year(launchTime), 2010)\n    )\n  ),\n  sort(\n    desc(price)\n  )\n)\";\n\n// Create the configured schema\nvar schema = new ApiSchema();\n\n// Execute the listSets() FunQL request\nvar result = await sets.AsQueryable()\n    .ExecuteRequest(schema, request);\n</code></pre> <p>The <code>ExecuteRequest()</code> method is designed for use cases where FunQL acts as a fully integrated query language. It  will process the <code>request</code> using the FunQL execution pipeline, which runs the following steps:</p> <ol> <li>Parse the <code>request</code> using the <code>listSets</code> request configuration</li> <li>Validate the parameters based on the <code>listSets</code> request configuration</li> <li>Translate the parameters to LINQ expressions</li> <li>Apply the LINQ expressions to given <code>IQueryable&lt;Set&gt;</code></li> <li>Execute the query, fetching the filtered and sorted result</li> </ol> <p>This example demonstrates how to query an in-memory data source. However, in real-world applications, you will typically  need to:</p> <ul> <li> <p>Query an external database: FunQL translates queries into LINQ expressions, enabling seamless integration with any   LINQ-compatible data provider, such as Entity Framework Core, Dapper, or others. This allows you to execute queries    directly against your database.</p> <p>Learn how to integrate FunQL with Entity Framework Core \u2192</p> </li> <li> <p>Enhance your REST API with FunQL: Utilize FunQL as part of your REST API by supporting advanced query capabilities    like filtering, sorting, and pagination through URL query parameters.</p> <p>Learn how to use FunQL in a REST API \u2192</p> </li> </ul>"},{"location":"executing-queries/pipeline/","title":"Execution pipeline","text":"<p>Work in Progress</p> <p>We are actively working on the documentation for FunQL .NET. Please check back later or visit our repository to track progress or contribute.</p>"},{"location":"integrations/","title":"Integrations","text":"<p>FunQL .NET is designed with extensibility at its core, making it highly adaptable to different technologies and  libraries in the .NET ecosystem. This section covers how popular .NET libraries can be integrated with FunQL.</p>"},{"location":"integrations/#entity-framework-core","title":"Entity Framework Core","text":"<p>FunQL seamlessly integrates with Entity Framework Core, using <code>IQueryable</code> LINQ expressions that EF Core efficiently translates into database queries. While this integration works out of the box, you can enhance it further by implementing EF Core-specific optimizations, such as using <code>CountAsync()</code> for improved async performance with FunQL's <code>count()</code> parameter.</p> <p>Learn more about integrating Entity Framework Core \u2192</p>"},{"location":"integrations/#nodatime","title":"NodaTime","text":"<p>Noda Time is a great alternative date and time API for .NET. Using NodaTime with FunQL requires configuring JSON serialization to handle NodaTime types (<code>Instant</code>, <code>LocalDate</code>, <code>LocalDateTime</code>). Additionally, to use FunQL DateTime functions (<code>year()</code>, <code>month()</code>, <code>day()</code>) with NodaTime types, you'll need to add a custom LINQ  translator.</p> <p>Learn more about integrating NodaTime \u2192</p>"},{"location":"integrations/#newtonsoftjson","title":"Newtonsoft.Json","text":"<p>FunQL uses System.Text.Json  by default for JSON serialization, as it's built into .NET. For projects requiring Newtonsoft.Json (JSON.NET), FunQL allows for fully customizing the serialization process.</p> <p>Learn more about integrating Newtonsoft.Json \u2192</p>"},{"location":"integrations/efcore/","title":"Entity Framework Core","text":"<p>Entity Framework Core (EF Core) is a powerful Object-Relational Mapper  (ORM) for .NET that allows developers to interact with databases using .NET objects and LINQ. FunQL seamlessly  integrates with EF Core by translating FunQL queries into LINQ expressions, which EF Core further translates to database  queries.</p> <p>This section will explain more about integrating FunQL with EF Core and using EF Core-specific optimizations (e.g.,  <code>CountAsync</code> for asynchronous count operations).</p> <p>You can also refer to the WebApi sample for a practical example of the EF Core integration.</p>"},{"location":"integrations/efcore/#getting-started","title":"Getting started","text":"<p>FunQL offers seamless integration with EF Core by working directly with <code>IQueryable</code> objects. Create a <code>DbContext</code> and  then directly execute FunQL queries using <code>DbSet&lt;T&gt;</code>, which implements <code>IQueryable</code>.</p>"},{"location":"integrations/efcore/#1-create-dbcontext","title":"1. Create DbContext","text":"<p>To begin, let's define a simple <code>DbContext</code> that represents our database. In this example, we'll create a context for  querying LEGO sets (as configured in Defining a Schema):</p> <pre><code>public sealed record Set(string Name, double Price, DateTime LaunchTime);\n\npublic sealed class ApiSchema : Schema\n{\n    // Code omitted for brevity, see 'Defining a Schema'\n}\n\npublic class ApiContext : DbContext \n{\n    public DbSet&lt;Set&gt; Sets { get; set; }    \n\n    protected override void OnConfiguring(DbContextOptionsBuilder options)\n    {\n        // Replace with your database configuration\n        options.UseSqlServer(\"YourConnectionStringHere\");\n    }\n}\n</code></pre>"},{"location":"integrations/efcore/#2-execute-funql-query","title":"2. Execute FunQL query","text":"<p>With the <code>DbContext</code> configured, you can execute FunQL queries directly on a <code>DbSet&lt;T&gt;</code>. FunQL translates these queries into LINQ expressions, which EF Core then optimizes into database queries.</p> <p>Here's an example that queries LEGO sets priced at or above 500, sorted by price in descending order:</p> <pre><code>// Create the configured DbContext\nvar context = new ApiContext();\n// Create the configured schema\nvar schema = new ApiSchema();\n\n// Execute the listSets() FunQL request on ApiContext.Sets\nvar result = await context\n    .Sets\n    .ExecuteRequestForParameters(\n        schema, \n        requestName: \"listSets\", \n        filter: \"gte(price, 500)\", \n        sort: \"desc(price)\"\n    );\n</code></pre> <p>Note</p> <p>In a real-world application, it's recommended to configure and manage your <code>DbContext</code> using dependency injection  and not create an instance directly.</p> <p>That's it! FunQL seamlessly filters, sorts, and queries your database directly through the <code>DbSet&lt;Set&gt;</code>, leveraging EF  Core's powerful capabilities.</p>"},{"location":"integrations/efcore/#optimizing-async-support","title":"Optimizing async support","text":"<p>While FunQL integrates with EF Core out of the box, operations like counting can be further optimized. Using EF Core's  specialized async methods, such as <code>CountAsync()</code> for counting and <code>ToListAsync()</code> for data retrieval, improves performance.</p> <p>Note</p> <p>FunQL executes LINQ queries asynchronously out of the box if <code>IQueryable</code> implements <code>IAsyncEnumerable</code>. The  implementation is equivalent to calling EF Core's <code>ToListAsync()</code> method. However, there's no generic interface for  async counting, making it necessary to explicitly use EF Core's <code>CountAsync()</code> via a custom execution handler when  using FunQL's <code>count()</code> parameter.</p>"},{"location":"integrations/efcore/#1-create-execution-handler","title":"1. Create execution handler","text":"<p>Implement a custom <code>IExecutionHandler</code> to override the default implementation and directly use EF Core's async methods:</p> <pre><code>/// &lt;summary&gt;\n/// Execution handler that executes the &lt;see cref=\"ExecuteLinqExecuteContext.Queryable\"/&gt; to get the data for\n/// &lt;see cref=\"IExecutorState.Request\"/&gt;.\n/// &lt;para&gt;\n/// This handler replaces the &lt;see cref=\"ExecuteLinqExecutionHandler\"/&gt; so it can use the async EFCore methods instead:\n/// &lt;list type=\"bullet\"&gt;\n/// &lt;item&gt;\n/// &lt;description&gt;\n///   &lt;see cref=\"EntityFrameworkQueryableExtensions.ToListAsync{T}(IQueryable{T},CancellationToken)\"/&gt; to get the data\n/// &lt;/description&gt;\n/// &lt;/item&gt;\n/// &lt;item&gt;\n/// &lt;description&gt;\n///   &lt;see cref=\"EntityFrameworkQueryableExtensions.CountAsync{T}(IQueryable{T},CancellationToken)\"/&gt; to count the items\n/// &lt;/description&gt;\n/// &lt;/item&gt;\n/// &lt;/list&gt;\n/// &lt;/para&gt;\n/// &lt;/summary&gt;\n/// &lt;remarks&gt;\n/// Requires &lt;see cref=\"ExecuteLinqExecuteContext\"/&gt; context, just like &lt;see cref=\"ExecuteLinqExecutionHandler\"/&gt;.\n///\n/// &lt;para&gt;\n/// Note that &lt;see cref=\"ExecuteLinqExecutionHandler\"/&gt; already handles &lt;see cref=\"IAsyncEnumerable{T}\"/&gt; the same or\n/// similar to how &lt;see cref=\"EntityFrameworkQueryableExtensions.ToListAsync{T}(IQueryable{T},CancellationToken)\"/&gt;\n/// handles it. Only the &lt;see cref=\"EntityFrameworkQueryableExtensions.CountAsync{T}(IQueryable{T},CancellationToken)\"/&gt;\n/// is different as there's no abstract way to count asynchronously; this is a specific implementation in EFCore.\n/// &lt;/para&gt;\n/// &lt;/remarks&gt;\npublic class EntityFrameworkCoreExecuteLinqExecutionHandler : IExecutionHandler\n{\n    /// &lt;summary&gt;Default name of this handler.&lt;/summary&gt;\n    public const string DefaultName = \"WebApi.EntityFrameworkCoreExecuteLinqExecutionHandler\";\n\n    // Handler should be called late in the pipeline as LINQ does the data fetching, which is pretty much at the end\n    /// &lt;summary&gt;Default order of this handler.&lt;/summary&gt;\n    /// &lt;remarks&gt;\n    /// Should be called before &lt;see cref=\"ExecuteLinqExecutionHandler\"/&gt; so this handler can take over the execution.\n    /// &lt;/remarks&gt;\n    public const int DefaultOrder = ExecuteLinqExecutionHandler.DefaultOrder - 100;\n\n    /// &lt;inheritdoc/&gt;\n    public async Task Execute(IExecutorState state, ExecutorDelegate next, CancellationToken cancellationToken)\n    {\n        var context = state.FindContext&lt;ExecuteLinqExecuteContext&gt;();\n        // Early return if no ExecuteLinqExecuteContext set\n        if (context == null)\n        {\n            await next(state, cancellationToken);\n            return;\n        }\n\n        var queryable = context.Queryable;\n        var countQueryable = context.CountQueryable;\n\n        // Query the data\n        state.Data = await EntityFrameworkQueryableExtensions.ToListAsync((dynamic)queryable, cancellationToken);\n\n        // Count the data if necessary\n        if (countQueryable != null)\n        {\n            int totalCount = await EntityFrameworkQueryableExtensions.CountAsync(\n                (dynamic)countQueryable,\n                cancellationToken\n            );\n            state.SetTotalCount(totalCount);\n        }\n\n        // This is the last step that executes the request, so don't call next\n    }\n}\n</code></pre>"},{"location":"integrations/efcore/#2-add-extension-method","title":"2. Add extension method","text":"<p>To simplify integration, create an extension method to include the EF Core optimizations:</p> <pre><code>/// &lt;summary&gt;\n/// Extensions related to &lt;see cref=\"IExecuteConfigBuilder\"/&gt; and &lt;see cref=\"Microsoft.EntityFrameworkCore\"/&gt;.\n/// &lt;/summary&gt;\npublic static class ExecuteConfigBuilderEntityFrameworkCoreExtensions\n{\n    /// &lt;summary&gt;\n    /// Adds the &lt;see cref=\"EntityFrameworkCoreExecuteLinqExecutionHandler\"/&gt; to given &lt;paramref name=\"builder\"/&gt; if not\n    /// yet added.\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"builder\"&gt;Builder to configure.&lt;/param&gt;\n    /// &lt;returns&gt;The builder to continue building.&lt;/returns&gt;\n    public static IExecuteConfigBuilder WithEntityFrameworkCoreExecuteLinqExecutionHandler(\n        this IExecuteConfigBuilder builder\n    )\n    {\n        // Lazy provider so handler is only created when executing\n        IExecutionHandler? handler = null;\n        return builder.WithExecutionHandler(\n            EntityFrameworkCoreExecuteLinqExecutionHandler.DefaultName,\n            _ =&gt; handler ??= new EntityFrameworkCoreExecuteLinqExecutionHandler(),\n            EntityFrameworkCoreExecuteLinqExecutionHandler.DefaultOrder\n        );\n    }\n}\n</code></pre>"},{"location":"integrations/efcore/#3-configure-schema","title":"3. Configure Schema","text":"<p>Finally, update your schema to include the custom EF Core execution handler:</p> <pre><code>public sealed class ApiSchema : Schema { \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) {                 \n        schema.AddExecuteFeature(it =&gt;\n        {\n            // Add the EntityFrameworkCoreExecuteLinqExecutionHandler so specific EF Core methods are used \n            it.WithEntityFrameworkCoreExecuteLinqExecutionHandler();\n        });\n    }\n}\n</code></pre> <p>That's it, FunQL will now directly use EF Core's async methods when executing queries.</p>"},{"location":"integrations/newtonsoftjson/","title":"Newtonsoft.Json","text":"<p>FunQL uses System.Text.Json  by default for JSON serialization. However, if your project requires Newtonsoft.Json  (JSON.NET), FunQL can seamlessly integrate it for both serialization and deserialization.</p> <p>This section explains how to integrate Newtonsoft.Json with FunQL for both parsing (deserializing) and printing  (serializing) constants.</p>"},{"location":"integrations/newtonsoftjson/#configuring-deserialization","title":"Configuring deserialization","text":"<p>To parse FunQL constants (e.g., <code>true</code>, <code>\"name\"</code>, <code>123</code>, or objects/arrays) using Newtonsoft.Json, we will need to  override the default <code>IConstantParser</code>. First, we create a parser that uses Newtonsoft.Json, and then we configure our  schema to use it.</p>"},{"location":"integrations/newtonsoftjson/#1-create-the-parser","title":"1. Create the parser","text":"<p>Implement a custom <code>IConstantParser</code> that uses <code>JsonConvert.DeserializeObject()</code> to deserialize JSON strings into FunQL  constants.</p> <pre><code>/// &lt;summary&gt;\n/// Implementation of &lt;see cref=\"IConstantParser\"/&gt; that uses &lt;see cref=\"JsonConvert\"/&gt; to parse the\n/// &lt;see cref=\"Constant\"/&gt; node.\n/// &lt;/summary&gt;\n/// &lt;param name=\"jsonSerializerSettings\"&gt;Settings for &lt;see cref=\"Newtonsoft.Json\"/&gt;.&lt;/param&gt;\n/// &lt;inheritdoc/&gt;\npublic class NewtonsoftJsonConstantParser(\n    JsonSerializerSettings jsonSerializerSettings\n) : IConstantParser\n{\n    /// &lt;summary&gt;Options for &lt;see cref=\"Newtonsoft.Json\"/&gt;.&lt;/summary&gt;\n    private readonly JsonSerializerSettings _jsonSerializerSettings = jsonSerializerSettings;\n\n    /// &lt;inheritdoc/&gt;\n    public Constant ParseConstant(IParserState state)\n    {\n        state.IncreaseDepth();\n\n        var expectedType = state.RequireContext&lt;ConstantParseContext&gt;().ExpectedType;\n        // If Type is a primitive/struct (int, double, DateTime, etc.), we should make it Nullable as 'null' is a valid\n        // constant, but JsonConvert can only read 'null' if Type can be null\n        expectedType = expectedType.ToNullableType();\n\n        var token = state.CurrentToken();\n        switch (token.Type)\n        {\n            case TokenType.String:\n            case TokenType.Number:\n            case TokenType.Boolean:\n            case TokenType.Null:\n            case TokenType.Object:\n            case TokenType.Array:\n                // Valid token for constants\n                break;\n            case TokenType.OpenBracket:\n                // Handle OpenBracket token as Array \n                token = state.CurrentTokenAsArray();\n                break;\n            case TokenType.None:\n            case TokenType.Eof:\n            case TokenType.Identifier:\n            case TokenType.OpenParen:\n            case TokenType.CloseParen:\n            case TokenType.Comma:\n            case TokenType.Dot:\n            case TokenType.Dollar:\n            case TokenType.CloseBracket:\n            default:\n                // Invalid token for constants\n                throw state.Lexer.SyntaxException($\"Expected constant at position {token.Position}, but found '{token.Text}'.\");\n        }\n\n        var metadata = state.CreateMetadata();\n\n        try\n        { \n            var value = JsonConvert.DeserializeObject(token.Text, expectedType, _jsonSerializerSettings);\n            // Successfully parsed, so go to next token\n            state.NextToken();\n\n            state.DecreaseDepth();\n            return new Constant(value, metadata);\n        }\n        catch (Exception e) when (e is JsonException)\n        {\n            throw new ParseException($\"Failed to parse constant '{token.Text}' at position {token.Position}.\", e);\n        }\n    }\n}\n</code></pre> <p>Note</p> <p>This code is based on the default implementation, adapted to  use Newtonsoft.Json instead of System.Text.Json.</p>"},{"location":"integrations/newtonsoftjson/#2-configure-schema","title":"2. Configure Schema","text":"<p>To use the <code>NewtonsoftJsonConstantParser</code>, override the default <code>IConstantParser</code> in your schema's <code>OnInitializeSchema</code>  method.</p> <pre><code>public sealed class ApiSchema : Schema { \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) {\n        schema.AddParseFeature(it =&gt;\n        {\n            IConstantParser? constantParser = null;\n            it.MutableConfig.ConstantParserProvider = _ =&gt; constantParser ??= new NewtonsoftJsonConstantParser(\n                new JsonSerializerSettings()\n            );\n        });\n    }\n}\n</code></pre> <p>Now, when you parse a FunQL query, the <code>NewtonsoftJsonConstantParser</code> will be used to parse the constants. You can also  configure the <code>JsonSerializerSettings</code> as needed, adding custom converters, naming strategies, etc.</p>"},{"location":"integrations/newtonsoftjson/#configuring-serialization","title":"Configuring serialization","text":"<p>When printing FunQL queries to a string, the <code>Constant</code> nodes are serialized to JSON using the <code>IConstantPrintVisitor</code>.  First, we implement this class to use Newtonsoft.Json, and then we configure the schema to use this implementation.</p>"},{"location":"integrations/newtonsoftjson/#1-create-the-print-visitor","title":"1. Create the print visitor","text":"<p>The <code>NewtonsoftJsonConstantPrintVisitor</code> serializes FunQL constants into JSON strings using  <code>JsonConvert.SerializeObject()</code>.</p> <pre><code>/// &lt;summary&gt;Implementation of &lt;see cref=\"IConstantPrintVisitor{TState}\"/&gt; using &lt;see cref=\"JsonConvert\"/&gt;.&lt;/summary&gt;\n/// &lt;param name=\"jsonSerializerSettings\"&gt;Settings for &lt;see cref=\"Newtonsoft.Json\"/&gt;.&lt;/param&gt;\n/// &lt;inheritdoc cref=\"IConstantPrintVisitor{TState}\"/&gt;\npublic class NewtonsoftJsonConstantPrintVisitor&lt;TState&gt;(\n    JsonSerializerSettings jsonSerializerSettings\n) : ConstantVisitor&lt;TState&gt;, IConstantPrintVisitor&lt;TState&gt; where TState : IPrintVisitorState\n{\n    /// &lt;summary&gt;Settings to use when writing JSON.&lt;/summary&gt;\n    private readonly JsonSerializerSettings _jsonSerializerSettings = jsonSerializerSettings;\n\n    /// &lt;inheritdoc/&gt;\n    public override Task Visit(Constant node, TState state, CancellationToken cancellationToken) =&gt;\n        state.OnVisit(node, async ct =&gt;\n        {\n            var jsonValue = JsonConvert.SerializeObject(node.Value, _jsonSerializerSettings);\n            await state.Write(jsonValue, ct);\n        }, cancellationToken);\n}\n</code></pre> <p>Note</p> <p>This code is based on the default implementation,  adapted to use Newtonsoft.Json instead of System.Text.Json.</p>"},{"location":"integrations/newtonsoftjson/#2-configure-schema_1","title":"2. Configure Schema","text":"<p>To use the <code>NewtonsoftJsonConstantPrintVisitor</code>, override the default <code>IConstantPrintVisitor</code> in your schema's  <code>OnInitializeSchema</code> method.</p> <pre><code>public sealed class ApiSchema : Schema { \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) {\n        schema.AddPrintFeature(it =&gt;\n        {\n            IConstantPrintVisitor&lt;IPrintVisitorState&gt;? constantPrintVisitor = null;\n            it.MutableConfig.ConstantPrintVisitorProvider = _ =&gt; \n                constantPrintVisitor ??= new NewtonsoftJsonConstantPrintVisitor&lt;IPrintVisitorState&gt;(\n                    new JsonSerializerSettings()\n                );\n        });\n    }\n}\n</code></pre> <p>Now, when you print a FunQL query, the <code>NewtonsoftJsonConstantPrintVisitor</code> will be used to serialize the constants.</p>"},{"location":"integrations/nodatime/","title":"NodaTime","text":"<p>Noda Time is a great alternative date and time API for .NET. However, integrating NodaTime with FunQL requires additional configuration to handle JSON serialization and support FunQL's DateTime functions, such as  <code>year()</code>, <code>month()</code>, and <code>day()</code>.</p> <p>You can also refer to the WebApi sample for a  practical example of the NodaTime integration.</p>"},{"location":"integrations/nodatime/#configuring-json-serialization","title":"Configuring JSON serialization","text":"<p>To handle NodaTime types (<code>Instant</code>, <code>LocalDate</code>, <code>LocalDateTime</code>), you must configure JSON serialization. FunQL uses  <code>System.Text.Json</code> by default, and the easiest way to add support for NodaTime types is through the  NodaTime.Serialization.SystemTextJson library.</p>"},{"location":"integrations/nodatime/#1-install-the-package","title":"1. Install the package","text":"<p>Run the following command to add the NodaTime.Serialization.SystemTextJson library:</p> <pre><code>dotnet add package NodaTime.Serialization.SystemTextJson\n</code></pre>"},{"location":"integrations/nodatime/#2-configure-json-for-nodatime","title":"2. Configure JSON for NodaTime","text":"<p>Update your <code>Schema</code> to include a custom <code>JsonSerializerOptions</code> configuration with NodaTime support:</p> <pre><code>public sealed class ApiSchema : Schema { \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) {     \n        // Create custom JsonSerializerOptions for FunQL\n        var jsonSerializerOptions = new JsonSerializerOptions() \n            // Add support for NodaTime types\n            .ConfigureForNodaTime(DateTimeZoneProviders.Tzdb);\n\n        // Apply the configured JsonSerializerOptions to FunQL\n        schema.JsonConfig()\n            .WithJsonSerializerOptions(jsonSerializerOptions);\n    }\n}\n</code></pre> <p>This ensures that NodaTime types are correctly serialized and deserialized when interacting with FunQL.</p>"},{"location":"integrations/nodatime/#supporting-datetime-functions","title":"Supporting DateTime functions","text":"<p>FunQL's built-in DateTime functions (<code>year()</code>, <code>month()</code>, <code>day()</code>) only work with .NET's <code>DateTime</code> type by default. To  enable these functions for NodaTime's <code>Instant</code> type, we need to add a custom translator.</p>"},{"location":"integrations/nodatime/#1-create-instant-translator","title":"1. Create Instant translator","text":"<p>Implement a custom <code>FieldFunctionLinqTranslator</code> that converts NodaTime's <code>Instant</code> to .NET's <code>DateTime</code>. This makes the  FunQL DateTime functions compatible with NodaTime types:</p> <pre><code>/// &lt;summary&gt;Translator for &lt;see cref=\"Instant\"/&gt; functions.&lt;/summary&gt;\n/// &lt;remarks&gt;\n/// Translates &lt;see cref=\"Instant\"/&gt; to &lt;see cref=\"DateTime\"/&gt; and then delegates the translation logic to\n/// &lt;see cref=\"DateTimeFunctionLinqTranslator\"/&gt;, so e.g. &lt;see cref=\"Year\"/&gt; and &lt;see cref=\"Month\"/&gt; field functions can\n/// be used on &lt;see cref=\"Instant\"/&gt; types.\n/// &lt;/remarks&gt;\npublic class InstantFunctionLinqTranslator : FieldFunctionLinqTranslator\n{\n    /// &lt;summary&gt;Empty &lt;see cref=\"Instant\"/&gt; we can use to get &lt;see cref=\"MethodInfo\"/&gt;.&lt;/summary&gt;\n    // ReSharper disable once RedundantDefaultMemberInitializer\n    private static readonly Instant DefaultInstant = default;\n    /// &lt;summary&gt;The &lt;see cref=\"MethodInfo\"/&gt; for &lt;see cref=\"Instant.ToDateTimeUtc\"/&gt;.&lt;/summary&gt;\n    private static readonly MethodInfo InstantToDateTimeUtcMethod =\n        MethodInfoUtil.MethodOf(DefaultInstant.ToDateTimeUtc);\n\n    /// &lt;summary&gt;The &lt;see cref=\"DateTime\"/&gt; translator to delegate translation logic to.&lt;/summary&gt;\n    private static readonly DateTimeFunctionLinqTranslator DateTimeFunctionLinqTranslator = new();\n\n    /// &lt;inheritdoc/&gt;\n    public override Expression? Translate(FieldFunction node, Expression source, ILinqVisitorState state)\n    {\n        if (source.Type.UnwrapNullableType() != typeof(Instant))\n            return null;\n\n        // Translate Instant to DateTime so we can use DateTime methods instead\n        source = LinqExpressionUtil.CreateFunctionCall(\n            InstantToDateTimeUtcMethod,\n            state.HandleNullPropagation,\n            source\n        );\n\n        return DateTimeFunctionLinqTranslator.Translate(node, source, state);\n    }\n}\n</code></pre>"},{"location":"integrations/nodatime/#2-add-extension-method","title":"2. Add extension method","text":"<p>To simplify adding NodaTime support to FunQL, create an extension method for the LINQ configuration:</p> <pre><code>/// &lt;summary&gt;Extensions related to &lt;see cref=\"ILinqConfigBuilder\"/&gt; and &lt;see cref=\"NodaTime\"/&gt;.&lt;/summary&gt;\npublic static class LinqConfigBuilderNodaTimeExtensions\n{\n    /// &lt;summary&gt;\n    /// Adds the &lt;see cref=\"InstantFunctionLinqTranslator\"/&gt; to given &lt;paramref name=\"builder\"/&gt; if not yet added.\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"builder\"&gt;Builder to configure.&lt;/param&gt;\n    /// &lt;returns&gt;The builder to continue building.&lt;/returns&gt;\n    public static ILinqConfigBuilder WithInstantFunctionLinqTranslator(\n        this ILinqConfigBuilder builder\n    )\n    {\n        // Early return if translator already added\n        if (builder.MutableConfig.GetFieldFunctionLinqTranslators().Any(it =&gt; it is InstantFunctionLinqTranslator))\n            return builder;\n\n        builder.MutableConfig.AddFieldFunctionLinqTranslator(new InstantFunctionLinqTranslator());\n\n        return builder;\n    }\n}\n</code></pre>"},{"location":"integrations/nodatime/#3-configure-schema","title":"3. Configure Schema","text":"<p>Finally, update your schema to include the custom translator for NodaTime's <code>Instant</code>:</p> <pre><code>public sealed class ApiSchema : Schema { \n    protected override void OnInitializeSchema(ISchemaConfigBuilder schema) {         \n        schema.AddLinqFeature(it =&gt;\n        {\n            // Add DateTime function support for NodaTime Instant\n            it.WithInstantFunctionLinqTranslator();\n        });\n    }\n}\n</code></pre> <p>That's it, you can now use FunQL's DateTime functions on <code>Instant</code> types.</p>"}]}